::
:: This file generates three different headers: string.h, cstring, and
:: string. The "default" wsplice operation produces string.h, the header
:: used in the C library. A CNAME wsplice operation produces cstring, the
:: C++ partner to C's string.h. A special CPPSTRING wsplice operation
:: generates C++'s string header. That header is not directly related to
:: either string.h or cstring; it contains the definition of the character
:: traits template and std::string.
:: (Peter Chapin)
::
:segment !CPPSTRING
/***************************************************************************
 * FILE: string.h/cstring (String functions)
 *
:include crwat.sp
 *
 * Description: This header is part of the C/C++ standard library. It
 *              declares functions of use for manipulating null terminated
 *              arrays of characters. 
 ***************************************************************************/
:segment CNAME
#ifndef _CSTRING_INCLUDED
#define _CSTRING_INCLUDED

#ifndef __cplusplus
#error The header cstring requires C++
#endif
:elsesegment
#ifndef _STRING_H_INCLUDED
#define _STRING_H_INCLUDED
:endsegment

:include readonly.sp
::
:: The following segment only appears in string.h.
:segment !CNAME
#ifdef __cplusplus
#include <cstring>

// C99 types in string.h.
#ifndef _SIZE_T_DEFINED
#define _SIZE_T_DEFINED
#define _SIZE_T_DEFINED_
using std::size_t;
#endif
#ifndef _WCTYPE_T_DEFINED
#define _WCTYPE_T_DEFINED
#define _WCTYPE_T_DEFINED_
using std::wint_t;
using std::wctype_t;
#endif

// C99 functions in string.h
using std::memchr;
using std::memcmp;
using std::memcpy;
using std::memmove;
using std::memset;
using std::strcat;
using std::strchr;
using std::strcmp;
using std::strcoll;
using std::strcpy;
using std::strcspn;
using std::strerror;
using std::strlen;
using std::strncat;
using std::strncmp;
using std::strncpy;
using std::strpbrk;
using std::strrchr;
using std::strspn;
using std::strstr;
using std::strtok;
using std::strxfrm;

:include ext.sp
// C99 functions not officially in string.h
:segment !NO_WIDECHAR
using std::wcscat;
using std::wcschr;
using std::wcscmp;
using std::wcscoll;
using std::wcscpy;
using std::wcscspn;
using std::wcslen;
using std::wcsncat;
using std::wcsncmp;
using std::wcsncpy;
using std::wcspbrk;
using std::wcsrchr;
using std::wcsspn;
using std::wcsstr;
using std::wcstok;
using std::wcsxfrm;
:endsegment
#endif

#else /* __cplusplus not defined */
:: End of segment that is only in string.h
:endsegment

:: Only need extern "C" in cstring
:segment CNAME
:include cpluspro.sp
:endsegment

#ifndef _COMDEF_H_INCLUDED
 #include <_comdef.h>
#endif

:include wchar_t.sp

:include wctypet.sp

:include sizet.sp

:include null.sp

:include nlserror.sp

:segment CNAME
namespace std {
:endsegment
_WCIRTLINK extern void   *memchr( const void *__s, int __c, size_t __n );
_WCIRTLINK extern int     memcmp( const void *__s1, const void *__s2, size_t __n );
_WCIRTLINK extern void   *memcpy( void *__s1, const void *__s2, size_t __n );
_WCRTLINK  extern void   *memmove( void *__s1, const void *__s2, size_t __n );
#if defined(M_I86)
_WCIRTLINK
#else
_WCRTLINK
#endif
           extern void   *memset( void *__s, int __c, size_t __n );
_WCIRTLINK extern char   *strcat( char *__s1, const char *__s2 );
_WCIRTLINK extern char   *strchr( const char *__s, int __c );
#if defined(M_I86)
_WCIRTLINK
#else
_WCRTLINK
#endif
           extern int     strcmp( const char *__s1, const char *__s2 );
_WCRTLINK  extern int     strcoll( const char *__s1, const char *__s2 );
_WCIRTLINK extern char   *strcpy( char *__s1, const char *__s2 );
_WCRTLINK  extern size_t  strcspn( const char *__s1, const char *__s2 );
_WCRTLINK  extern char   *strerror( int __errnum );
_WCIRTLINK extern size_t  strlen( const char *__s );
_WCRTLINK  extern char   *strncat( char *__s1, const char *__s2, size_t __n );
_WCRTLINK  extern int     strncmp( const char *__s1, const char *__s2, size_t __n );
_WCRTLINK  extern char   *strncpy( char *__s1, const char *__s2, size_t __n );
_WCRTLINK  extern char   *strpbrk( const char *__s1, const char *__s2 );
_WCRTLINK  extern char   *strrchr( const char *__s, int __c );
_WCRTLINK  extern size_t  strspn( const char *__s1, const char *__s2 );
_WCRTLINK  extern char   *strstr( const char *__s1, const char *__s2 );
_WCRTLINK  extern char   *strtok( char *__s1, const char *__s2 );
_WCRTLINK  extern size_t  strxfrm( char *__s1, const char *__s2, size_t __n );
:segment CNAME
}
:endsegment

:segment !SNAPDRV
_WCRTLINK  extern int _stricoll( const char *__s1, const char *__s2 );
_WCRTLINK  extern int _strncoll( const char *__s1, const char *__s2, _w_size_t __n );
_WCRTLINK  extern int _strnicoll( const char *__s1, const char *__s2, _w_size_t __n );
:endsegment

:include ext.sp
/* WATCOM's Additional Functions (non-ISO, non-POSIX) */

_WCRTLINK  extern char   *strspnp( const char *__s1, const char *__s2 );

:segment !SNAP & !SNAPDRV
#if !defined(_fmemccpy) || !defined(_INC_WINDOWSX)
_WCRTLINK extern void _WCFAR *_fmemccpy( void _WCFAR *__s1, const void _WCFAR *__s2, int __c, _w_size_t __n );
#endif
#if !defined(_fmemchr) || !defined(_INC_WINDOWSX)
_WCIRTLINK extern void _WCFAR *_fmemchr( const void _WCFAR *__s, int __c, _w_size_t __n );
#endif
#if !defined(_fmemcpy) || !defined(_INC_WINDOWSX)
_WCIRTLINK extern void _WCFAR *_fmemcpy( void _WCFAR *__s1, const void _WCFAR *__s2, _w_size_t __n );
#endif
#if !defined(_fmemmove) || !defined(_INC_WINDOWSX)
_WCRTLINK extern void _WCFAR *_fmemmove( void _WCFAR *__s1, const void _WCFAR *__s2, _w_size_t __n );
#endif
#if !defined(_fmemset) || !defined(_INC_WINDOWSX)
_WCIRTLINK extern void _WCFAR *_fmemset( void _WCFAR *__s, int __c, _w_size_t __n );
#endif
#if !defined(_fmemcmp) || !defined(_INC_WINDOWSX)
_WCIRTLINK extern int _fmemcmp( const void _WCFAR *__s1, const void _WCFAR *__s2, _w_size_t __n );
#endif
#if !defined(_fmemicmp) || !defined(_INC_WINDOWSX)
_WCRTLINK extern int _fmemicmp( const void _WCFAR *__s1, const void _WCFAR *__s2, _w_size_t __n );
#endif
#if !defined(_fstrcat) || !defined(_INC_WINDOWSX)
_WCIRTLINK extern char _WCFAR *_fstrcat( char _WCFAR *__s1, const char _WCFAR *__s2 );
#endif
#if !defined(_fstrchr) || !defined(_INC_WINDOWSX)
_WCRTLINK extern char _WCFAR *_fstrchr( const char _WCFAR *__s, int __c );
#endif
#if !defined(_fstrcmp) || !defined(_INC_WINDOWSX)
_WCIRTLINK extern int _fstrcmp( const char _WCFAR *__s1, const char _WCFAR *__s2 );
#endif
#if !defined(_fstrcpy) || !defined(_INC_WINDOWSX)
_WCIRTLINK extern char _WCFAR *_fstrcpy( char _WCFAR *__s1, const char _WCFAR *__s2 );
#endif
#if !defined(_fstrcspn) || !defined(_INC_WINDOWSX)
_WCRTLINK extern _w_size_t _fstrcspn( const char _WCFAR *__s1, const char _WCFAR *__s2 );
#endif
#if !defined(_fstrdup) || !defined(_INC_WINDOWSX)
_WCRTLINK extern char _WCFAR *_fstrdup( const char _WCFAR *__string );
#endif
#if !defined(_fstricmp) || !defined(_INC_WINDOWSX)
_WCRTLINK extern int _fstricmp( const char _WCFAR *__s1, const char _WCFAR *__s2 );
#endif
#if !defined(_fstrncat) || !defined(_INC_WINDOWSX)
_WCRTLINK extern char _WCFAR *_fstrncat( char _WCFAR *__s1, const char _WCFAR *__s2, _w_size_t __n );
#endif
#if !defined(_fstrlen) || !defined(_INC_WINDOWSX)
_WCIRTLINK extern _w_size_t _fstrlen( const char _WCFAR *__s );
#endif
#if !defined(_fstrlwr) || !defined(_INC_WINDOWSX)
_WCRTLINK extern char _WCFAR *_fstrlwr( char _WCFAR *__string );
#endif
#if !defined(_fstrncmp) || !defined(_INC_WINDOWSX)
_WCRTLINK extern int _fstrncmp( const char _WCFAR *__s1, const char _WCFAR *__s2, _w_size_t __n );
#endif
#if !defined(_fstrncpy) || !defined(_INC_WINDOWSX)
_WCRTLINK extern char _WCFAR *_fstrncpy( char _WCFAR *__s1, const char _WCFAR *__s2, _w_size_t __n );
#endif
#if !defined(_fstrnicmp) || !defined(_INC_WINDOWSX)
_WCRTLINK extern int _fstrnicmp( const char _WCFAR *__s1, const char _WCFAR *__s2, _w_size_t __n );
#endif
#if !defined(_fstrnset) || !defined(_INC_WINDOWSX)
_WCRTLINK extern char _WCFAR *_fstrnset( char _WCFAR *__string, int __c, _w_size_t __len );
#endif
#if !defined(_fstrpbrk) || !defined(_INC_WINDOWSX)
_WCRTLINK extern char _WCFAR *_fstrpbrk( const char _WCFAR *__s1, const char _WCFAR *__s2 );
#endif
#if !defined(_fstrrchr) || !defined(_INC_WINDOWSX)
_WCRTLINK extern char _WCFAR *_fstrrchr( const char _WCFAR *__s, int __c );
#endif
#if !defined(_fstrrev) || !defined(_INC_WINDOWSX)
_WCRTLINK extern char _WCFAR *_fstrrev( char _WCFAR *__string );
#endif
#if !defined(_fstrset) || !defined(_INC_WINDOWSX)
_WCRTLINK extern char _WCFAR *_fstrset( char _WCFAR *__string, int __c );
#endif
#if !defined(_fstrspn) || !defined(_INC_WINDOWSX)
_WCRTLINK extern _w_size_t _fstrspn( const char _WCFAR *__s1, const char _WCFAR *__s2 );
#endif
#if !defined(_fstrspnp) || !defined(_INC_WINDOWSX)
_WCRTLINK extern char _WCFAR *_fstrspnp( const char _WCFAR *__s1, const char _WCFAR *__s2 );
#endif
#if !defined(_fstrstr) || !defined(_INC_WINDOWSX)
_WCRTLINK extern char _WCFAR *_fstrstr( const char _WCFAR *__s1, const char _WCFAR *__s2 );
#endif
#if !defined(_fstrtok) || !defined(_INC_WINDOWSX)
_WCRTLINK extern char _WCFAR *_fstrtok( char _WCFAR *__s1, const char _WCFAR *__s2 );
#endif
#if !defined(_fstrupr) || !defined(_INC_WINDOWSX)
_WCRTLINK extern char _WCFAR *_fstrupr( char _WCFAR *__string );
#endif
_WCIRTLINK extern void movedata( unsigned __srcseg, unsigned __srcoff, unsigned __tgtseg, unsigned __tgtoff, unsigned __len );
:endsegment
:segment !SNAPDRV
_WCRTLINK extern int   bcmp( const void *__s1, const void *__s2, _w_size_t __n );
_WCRTLINK extern void  bcopy( const void *__s1, void *__s2, _w_size_t __n );
_WCRTLINK extern void  bzero( void *__s, _w_size_t __n );
:endsegment
_WCRTLINK extern void *memccpy( void *__s1, const void *__s2, int __c, _w_size_t __n );
:segment !SNAPDRV
_WCRTLINK extern int   memicmp( const void *__s1, const void *__s2, _w_size_t __n );
_WCRTLINK extern int   strcmpi( const char *__s1, const char *__s2 );
:endsegment
_WCRTLINK extern char *strdup( const char *__string );
_WCRTLINK extern int   stricmp( const char *__s1, const char *__s2 );
_WCRTLINK extern char *strlwr( char *__string );
_WCRTLINK extern int   strnicmp( const char *__s1, const char *__s2, _w_size_t __n );
:segment !SNAPDRV
_WCRTLINK extern char *strnset( char *__string, int __c, _w_size_t __len );
_WCRTLINK extern char *strrev( char *__string );
_WCRTLINK extern char *strset( char *__string, int __c );
:endsegment
_WCRTLINK extern char *strupr( char *__string );
:segment !SNAP & !SNAPDRV
#if defined(__NT__)
_WCRTLINK extern char *_doserror( int __oserrnum );
#endif
_WCRTLINK extern int   _memicmp( const void *__s1, const void *__s2, _w_size_t __n );
_WCRTLINK extern char *_strdup( const char *__string );
_WCRTLINK extern char *_strerror( const char *__s );
_WCRTLINK extern int   _stricmp( const char *__s1, const char *__s2 );
_WCRTLINK extern char *_strlwr( char *__string );
_WCRTLINK extern int   _strnicmp( const char *__s1, const char *__s2, _w_size_t __n );
_WCRTLINK extern char *_strnset( char *__string, int __c, _w_size_t __len );
_WCRTLINK extern char *_strrev( char *__string );
_WCRTLINK extern char *_strset( char *__string, int __c );
_WCRTLINK extern char *_strupr( char *__string );
:endsegment

:segment !NO_WIDECHAR
:segment CNAME
namespace std {
:endsegment
_WCRTLINK extern wchar_t *wcscat( wchar_t *, const wchar_t * );
_WCRTLINK extern wchar_t *wcschr( const wchar_t *, wint_t );
_WCRTLINK extern int      wcscmp( const wchar_t *, const wchar_t * );
_WCRTLINK extern int      wcscoll( const wchar_t *__s1, const wchar_t *__s2 );
_WCRTLINK extern wchar_t *wcscpy( wchar_t *, const wchar_t * );
_WCRTLINK extern size_t   wcscspn( const wchar_t *, const wchar_t * );
_WCRTLINK extern size_t   wcslen( const wchar_t * );
_WCRTLINK extern wchar_t *wcsncat( wchar_t *, const wchar_t *, size_t );
_WCRTLINK extern int      wcsncmp( const wchar_t *, const wchar_t *, size_t );
_WCRTLINK extern wchar_t *wcsncpy( wchar_t *, const wchar_t *, size_t );
_WCRTLINK extern wchar_t *wcspbrk( const wchar_t *, const wchar_t * );
_WCRTLINK extern wchar_t *wcsrchr( const wchar_t *, wint_t );
_WCRTLINK extern size_t   wcsspn( const wchar_t *, const wchar_t * );
_WCRTLINK extern wchar_t *wcsstr( const wchar_t *, const wchar_t * );
_WCRTLINK extern wchar_t *wcstok( wchar_t *, const wchar_t *, wchar_t ** );
_WCRTLINK extern size_t   wcsxfrm( wchar_t *__s1, const wchar_t *__s2, size_t __n );
:segment CNAME
}
:endsegment

_WCRTLINK extern int      wcscmpi( const wchar_t *, const wchar_t * );
_WCRTLINK extern wchar_t *wcserror( int );
:segment !SNAP & !SNAPDRV
#if defined(__NT__)
_WCRTLINK extern wchar_t *_wdoserror( int __errnum );
#endif
:endsegment

::_WCRTLINK extern wchar_t *wcsnset( wchar_t *, int, _w_size_t );
::_WCRTLINK extern int      wcsnicmp( const wchar_t *, const wchar_t *, _w_size_t );
::_WCRTLINK extern wchar_t *wcsdup( const wchar_t * );
::_WCRTLINK extern wchar_t *wcslwr( wchar_t * );
::_WCRTLINK extern wchar_t *wcsupr( wchar_t * );
::_WCRTLINK extern int      wcsicmp( const wchar_t *, const wchar_t * );
::_WCRTLINK extern wchar_t *wcsrev( wchar_t * );
::_WCRTLINK extern wchar_t *wcsset( wchar_t *, wchar_t );
::
_WCRTLINK extern wchar_t   *_ustrtok( wchar_t *, const wchar_t * );
_WCRTLINK extern wchar_t   *_wcsnset( wchar_t *, int, _w_size_t );
_WCRTLINK extern wchar_t   *_wcsspnp( const wchar_t *__s1, const wchar_t *__s2 );
_WCRTLINK extern int        _wcsnicmp( const wchar_t *, const wchar_t *, _w_size_t );
_WCRTLINK extern wchar_t   *_wcsdup( const wchar_t * );
_WCRTLINK extern wchar_t   *_wcslwr( wchar_t * );
_WCRTLINK extern wchar_t   *_wcsupr( wchar_t * );
_WCRTLINK extern int        _wcsicmp( const wchar_t *, const wchar_t * );
_WCRTLINK extern int        _wcsicoll( const wchar_t *__s1, const wchar_t *__s2 );
_WCRTLINK extern int        _wcsncoll( const wchar_t *__s1, const wchar_t *__s2, _w_size_t __n );
_WCRTLINK extern int        _wcsnicoll( const wchar_t *__s1, const wchar_t *__s2, _w_size_t __n );
_WCRTLINK extern wchar_t   *_wcsrev( wchar_t * );
_WCRTLINK extern wchar_t   *_wcsset( wchar_t *, wchar_t );
_WCRTLINK extern wchar_t   *_wcserror( const wchar_t * );
:endsegment

:segment LINUX
/* Additional Linux Functions */

_WCRTLINK extern int strcasecmp( const char *__s1, const char *__s2 );
_WCRTLINK extern int strncasecmp( const char *__s1, const char *__s2, _w_size_t __n );
:endsegment

:segment QNX
/* QNX's Additional Functions (non-ANSI, non-POSIX) */

extern void __strerror( int __max, int __errnum, char *__buf );
:endsegment
#endif  /* EXTENSIONS */

:segment !CNAME
#ifdef  __INLINE_FUNCTIONS__
:segment !SNAP & !SNAPDRV
:include ext.sp
 #pragma intrinsic(movedata,_fmemchr,_fmemcmp,_fmemcpy,_fmemset)
 #pragma intrinsic(_fstrcat,_fstrcmp,_fstrcpy,_fstrlen)
#endif
:endsegment
 #pragma intrinsic(memchr,memcmp,memcpy,strcat,strcpy,strlen,strchr)
 #if defined(M_I86)
  #pragma intrinsic(memset,strcmp)
 #endif
#endif  /* __INLINE_FUNCTIONS__ */
:endsegment

:segment CNAME
:include cplusepi.sp
:endsegment

:segment !CNAME
#endif /* __cplusplus */
:endsegment

#endif
:elsesegment
///////////////////////////////////////////////////////////////////////////
// FILE: string (Definition of character traits and std::string)
//
:keep CPP_HDR
:include crwat.sp
//
// Description: This header is part of the C++ standard library. It
//              defines the character traits template and the std::
//              string templates.
///////////////////////////////////////////////////////////////////////////
#ifndef _STRING_INCLUDED
#define _STRING_INCLUDED
:include readonly.sp

#ifndef __cplusplus
#error The header string requires C++
#endif

:: The header <_strdef.h> is indirectly included below.
#include <stdexcep.h>

namespace std {

  // ================================
  // Member functions of basic_string
  // ================================

  // basic_string( const basic_string &, size_type, size_type, ... )
  // ***************************************************************
  template< class CharT, class Traits, class Allocator >
  basic_string< CharT, Traits, Allocator >::basic_string(
    const basic_string &other,
    size_type  pos,
    size_type  n,
    const Allocator &a ) : mem( a )
  {
    if( pos > other.size( ) )
      throw out_of_range( "basic_string::basic_string" );

    size_type tail_length = other.size( ) - pos;
    size_type result_length = ( tail_length <= n ) ? tail_length : n;

    buffer = alloc( result_length + 1, total );
    Traits::copy( buffer, other.buffer + pos, result_length );
    filled = result_length;
  }

  // basic_string( const CharT *, size_type, const Allocator & )
  // ***********************************************************
  template< class CharT, class Traits, class Allocator >
  basic_string< CharT, Traits, Allocator >::basic_string(
    const CharT     *s,
    size_type        n,
    const Allocator &a ) : mem( a )
  {
    if( n == npos )
      throw length_error( "basic_string::basic_string" );

    buffer = alloc( n + 1, total );
    Traits::copy( buffer, s, n );
    filled = n;
  }

  // basic_string( size_type, CharT, const Allocator & )
  // ***************************************************
  template< class CharT, class Traits, class Allocator >
  basic_string< CharT, Traits, Allocator >::basic_string(
          size_type  n,
          CharT      c,
    const Allocator &a ) : mem( a )
  {
    if( n == npos )
      throw length_error( "basic_string::basic_string" );

    buffer = alloc( n + 1, total );
    Traits::assign( buffer, n, c );
    filled = n;
  }

  // operator=( const CharT * )
  // **************************
  template< class CharT, class Traits, class Allocator >
  basic_string< CharT, Traits, Allocator > &
    basic_string< CharT, Traits, Allocator >::operator=(
      const CharT *s )
  {
    // Prepare new buffer.
    size_type result_length = Traits::length( s );
    size_type new_total;
    pointer new_buffer = alloc( result_length + 1, new_total );
    Traits::copy( new_buffer, s, result_length );

    // Commit.
    mem.deallocate( buffer, total );
    buffer = new_buffer;
    total  = new_total;
    filled = result_length;
    return( *this );
  }

  // operator=( CharT )
  // ******************
  template< class CharT, class Traits, class Allocator >
  basic_string< CharT, Traits, Allocator > &
    basic_string< CharT, Traits, Allocator >::operator=(
      CharT c )
  {
    // Prepare a new buffer.
    size_type new_total;
    pointer new_buffer = alloc( 1 + 1, new_total );
    Traits::assign( *new_buffer, c );

    // Commit.
    mem.deallocate( buffer, total );
    buffer = new_buffer;
    total  = new_total;
    filled = 1;
    return( *this );
  }

  // assign( const basic_string &, size_type, size_type )
  // ****************************************************
  template< class CharT, class Traits, class Allocator >
  basic_string< CharT, Traits, Allocator > &
    basic_string< CharT, Traits, Allocator >::assign(
      const basic_string &str,
      size_type pos,
      size_type n )
  {
    basic_string temp( str, pos, n, mem );
    swap( *this, temp );
    return( *this );
  }

  // assign( const CharT *, size_type )
  // **********************************
  template< class CharT, class Traits, class Allocator >
  basic_string< CharT, Traits, Allocator > &
    basic_string< CharT, Traits, Allocator >::assign(
      const CharT *s,
      size_type n )
  {
    basic_string temp( s, n, mem );
    swap( *this, temp );
    return( *this );
  }

  // assign( const CharT * )
  // ***********************
  template< class CharT, class Traits, class Allocator >
  basic_string< CharT, Traits, Allocator > &
    basic_string< CharT, Traits, Allocator >::assign(
      const CharT *s )
  {
    basic_string temp( s, mem );
    swap( *this, temp );
    return( *this );
  }

  // assign( size_type, CharT )
  // **************************
  template< class CharT, class Traits, class Allocator >
  basic_string< CharT, Traits, Allocator > &
    basic_string< CharT, Traits, Allocator >::assign(
      size_type n,
      CharT c )
  {
    basic_string temp( n, c, mem );
    swap( *this, temp );
    return( *this );
  }

  // iterator begin( )
  // *****************
  template< class CharT, class Traits, class Allocator >
  inline
  basic_string< CharT, Traits, Allocator >::iterator
    basic_string< CharT, Traits, Allocator >::begin( )
  {
    return iterator( buffer );
  }

  // const_iterator begin( ) const
  // *****************************
  template< class CharT, class Traits, class Allocator >
  inline
  basic_string< CharT, Traits, Allocator >::const_iterator
    basic_string< CharT, Traits, Allocator >::begin( ) const
  {
    return const_iterator( buffer );
  }

  // iterator end( )
  // *****************
  template< class CharT, class Traits, class Allocator >
  inline
  basic_string< CharT, Traits, Allocator >::iterator
    basic_string< CharT, Traits, Allocator >::end( )
  {
    return iterator( buffer + filled );
  }

  // const_iterator end( ) const
  // ***************************
  template< class CharT, class Traits, class Allocator >
  inline
  basic_string< CharT, Traits, Allocator >::const_iterator
    basic_string< CharT, Traits, Allocator >::end( ) const
  {
    return const_iterator( buffer + filled );
  }

  // size( ) const
  // *************
  template< class CharT, class Traits, class Allocator >
  inline
  typename basic_string< CharT, Traits, Allocator >::size_type
    basic_string< CharT, Traits, Allocator >::size( ) const
  {
    return( filled );
  }

  // length( ) const
  // ***************
  template< class CharT, class Traits, class Allocator >
  inline
  typename basic_string< CharT, Traits, Allocator >::size_type
    basic_string< CharT, Traits, Allocator >::length( ) const
  {
    return( filled );
  }

  // capacity( ) const
  // *****************
  template< class CharT, class Traits, class Allocator >
  inline
  typename basic_string< CharT, Traits, Allocator >::size_type
    basic_string< CharT, Traits, Allocator >::capacity( ) const
  {
    return( total );
  }

  // operator[]( size_type ) const
  // *********************************
  template< class CharT, class Traits, class Allocator >
  inline
  typename basic_string< CharT, Traits, Allocator >::const_reference
    basic_string< CharT, Traits, Allocator >::operator[]( size_type pos ) const
  {
    return( buffer[pos] );
  }

  // operator[]( size_type )
  // ***************************
  template< class CharT, class Traits, class Allocator >
  inline
  typename basic_string< CharT, Traits, Allocator >::reference
    basic_string< CharT, Traits, Allocator >::operator[]( size_type pos )
  {
    return( buffer[pos] );
  }

  // at( size_type ) const
  // *********************
  template< class CharT, class Traits, class Allocator >
  inline
  typename basic_string< CharT, Traits, Allocator >::const_reference
    basic_string< CharT, Traits, Allocator >::at( size_type pos ) const
  {
    if( pos >= filled )
      throw out_of_range( "basic_string::at" );

    return( buffer[pos] );
  }

  // at( size_type )
  // ***************
  template< class CharT, class Traits, class Allocator >
  inline
  typename basic_string< CharT, Traits, Allocator >::reference
    basic_string< CharT, Traits, Allocator >::at( size_type pos )
  {
    if( pos >= filled )
      { throw out_of_range( "basic_string::at" ); }

    return( buffer[pos] );
  }

  // operator+=( const basic_string & )
  // **********************************
  template< class CharT, class Traits, class Allocator >
  inline
  basic_string< CharT, Traits, Allocator > &
    basic_string< CharT, Traits, Allocator >::operator+=(
      const basic_string &str )
  {
    return( append( str ) );
  }

  // operator+=( const CharT * )
  // ***************************
  template< class CharT, class Traits, class Allocator >
  inline
  basic_string< CharT, Traits, Allocator > &
    basic_string< CharT, Traits, Allocator >::operator+=( const CharT *s )
  {
    return( append( s ) );
  }

  // operator+=( CharT )
  // *******************
  template< class CharT, class Traits, class Allocator >
  inline
  basic_string< CharT, Traits, Allocator > &
    basic_string< CharT, Traits, Allocator >::operator+=( CharT c )
  {
    return( append( 1, c ) );
  }

  // append( const basic_string &, size_type, size_type )
  // ****************************************************
  template< class CharT, class Traits, class Allocator >
  basic_string< CharT, Traits, Allocator > &
    basic_string< CharT, Traits, Allocator >::append(
      const basic_string &str,
      size_type pos,
      size_type n )
  {
    if( pos > str.size( ) )
      throw out_of_range( "basic_string::append" );

    size_type tail_length = str.size( ) - pos;
    size_type append_length = ( tail_length <= n ) ? tail_length : n;

    if( filled >= npos - append_length - 1 )
      throw length_error( "basic_string::append" );

    if( append_length <= total - filled - 1) {
      Traits::copy( buffer + filled, str.buffer + pos, append_length );
      filled += append_length;
    }
    else {
      // Prepare new buffer.
      size_type result_length = filled + append_length;
      size_type new_total;
      pointer new_buffer = alloc( result_length + 1, new_total );
      Traits::copy( new_buffer, buffer, filled );
      Traits::copy( new_buffer + filled, str.buffer + pos, append_length );

      // Commit.
      mem.deallocate( buffer, total );
      buffer = new_buffer;
      total  = new_total;
      filled = result_length;
    }

    return( *this );
  }

  // append( const CharT *, size_type )
  // **********************************
  template< class CharT, class Traits, class Allocator >
  basic_string< CharT, Traits, Allocator > &
    basic_string< CharT, Traits, Allocator >::append(
      const CharT *s,
      size_type n )
  {
    if( filled >= npos - n - 1)
      throw length_error( "basic_string::append" );

    if( n <= total - filled - 1) {
      Traits::copy( buffer + filled, s, n );
      filled += n;
    }
    else {
      // Prepare new buffer.
      size_type result_length = filled + n;
      size_type new_total;
      pointer new_buffer = alloc( result_length + 1, new_total );
      Traits::copy( new_buffer, buffer, filled );
      Traits::copy( new_buffer + filled, s, n );

      // Commit.
      mem.deallocate( buffer, total );
      buffer = new_buffer;
      total  = new_total;
      filled = result_length;
    }

    return( *this );
  }

  // append( const CharT * )
  // ***********************
  template< class CharT, class Traits, class Allocator >
  inline
  basic_string< CharT, Traits, Allocator > &
    basic_string< CharT, Traits, Allocator >::append( const CharT *s )
  {
    return( append( s, Traits::length( s ) ) );
  }

  // append( size_type, CharT )
  // **************************
  template< class CharT, class Traits, class Allocator >
  basic_string< CharT, Traits, Allocator > &
    basic_string< CharT, Traits, Allocator >::append( size_type n, CharT c )
  {
    if( filled >= npos - n - 1 )
      throw length_error( "basic_string::append" );

    if( n <= total - filled - 1 ) {
      Traits::assign( buffer + filled, n, c );
      filled += n;
    }
    else {
      // Prepare new buffer.
      size_type result_length = filled + n;
      size_type new_total;
      pointer new_buffer = alloc( result_length + 1, new_total );
      Traits::copy( new_buffer, buffer, filled );
      Traits::assign( new_buffer + filled, n, c );

      // Commit.
      mem.deallocate( buffer, total );
      buffer = new_buffer;
      total  = new_total;
      filled = result_length;
    }

    return( *this );
  }

  // push_back( CharT )
  // ******************
  template< class CharT, class Traits, class Allocator >
  inline
  void basic_string< CharT, Traits, Allocator >::push_back( CharT c )
  {
    append( 1, c );
  }

  // insert( size_type, const basic_string &, size_type, size_type )
  // ***************************************************************
  template< class CharT, class Traits, class Allocator >
  basic_string< CharT, Traits, Allocator > &
    basic_string< CharT, Traits, Allocator >::insert(
      size_type pos1,
      const basic_string &str,
      size_type pos2,
      size_type n )
  {
    if( pos1 > filled || pos2 > str.size( ) )
      throw out_of_range( "basic_string::insert" );

    size_type tail_length = str.size( ) - pos2;
    size_type insert_length = ( tail_length <= n ) ? tail_length : n;

    if( filled >= npos - insert_length - 1)
      throw length_error( "basic_string::insert" );

    if( insert_length <= total - filled - 1) {
      Traits::move(
        buffer + pos1 + insert_length, buffer + pos1, filled - pos1 );
      Traits::copy(buffer + pos1, str.buffer + pos2, insert_length );
      filled += insert_length;
    }
    else {
      // Prepare new buffer.
      size_type result_length = filled + insert_length;
      size_type new_total;
      pointer new_buffer = alloc( result_length + 1, new_total );
      Traits::copy( new_buffer, buffer, pos1 );
      Traits::copy( new_buffer + pos1, str.buffer + pos2, insert_length );
      Traits::copy(
        new_buffer + pos1 + insert_length, buffer + pos1, filled - pos1 );

      // Commit.
      mem.deallocate( buffer, total );
      buffer = new_buffer;
      total  = new_total;
      filled = result_length;
    }

    return( *this );
  }

  // insert( size_type, const CharT *, size_type )
  // *********************************************
  template< class CharT, class Traits, class Allocator >
  basic_string< CharT, Traits, Allocator > &
    basic_string< CharT, Traits, Allocator >::insert(
      size_type pos,
      const CharT *s,
      size_type n )
  {
    // Inefficient. Go with it for now.
    return( insert( pos, basic_string( s, n ) ) );
  }

  // insert( size_type const CharT * )
  // *********************************
  template< class CharT, class Traits, class Allocator >
  basic_string< CharT, Traits, Allocator > &
    basic_string< CharT, Traits, Allocator >::insert(
      size_type pos,
      const CharT *s )
  {
    // Inefficient. Go with it for now.
    return( insert( pos, basic_string( s ) ) );
  }


  // insert( size_type size_type CharT )
  // ***********************************
  template< class CharT, class Traits, class Allocator >
  basic_string< CharT, Traits, Allocator > &
    basic_string< CharT, Traits, Allocator >::insert(
      size_type pos,
      size_type n,
      CharT c )
  {
    // Inefficient. Go with it for now.
    return( insert( pos, basic_string( n, c ) ) );
  }

  // insert( iterator, CharT )
  // *************************
  template< class CharT, class Traits, class Allocator >
  inline
  basic_string< CharT, Traits, Allocator >::iterator
    basic_string< CharT, Traits, Allocator >::insert( iterator p, CharT c )
  {
    insert( p, 1, c );
    return( p );
  }

  // insert( iterator, size_type, CharT )
  // ************************************
  template< class CharT, class Traits, class Allocator >
  void basic_string< CharT, Traits, Allocator >::insert(
    iterator p,
    size_type n,
    CharT c )
  {
    size_type insert_length = n;
    size_type pos = p - buffer;

    if( filled >= npos - insert_length - 1)
      throw length_error( "basic_string::insert" );

    if( insert_length <= total - filled - 1) {
      Traits::move( buffer + pos + insert_length, buffer + pos, filled - pos );
      Traits::assign( buffer + pos, insert_length, c );
      filled += insert_length;
    }
    else {
      // Prepare new buffer.
      size_type result_length = filled + insert_length;
      size_type new_total;
      pointer new_buffer = alloc( result_length + 1, new_total );
      Traits::copy( new_buffer, buffer, pos );
      Traits::assign( new_buffer + pos, insert_length, c );
      Traits::copy(
        new_buffer + pos + insert_length, buffer + pos, filled - pos );

      // Commit.
      mem.deallocate( buffer, total );
      buffer = new_buffer;
      total  = new_total;
      filled = result_length;
    }
  }

  // erase( size_type, size_type )
  // *****************************
  template< class CharT, class Traits, class Allocator >
  basic_string< CharT, Traits, Allocator > &
    basic_string< CharT, Traits, Allocator >::erase(
      size_type pos,
      size_type n )
  {
    if( pos > size( ) )
      throw out_of_range( "basic_string::erase" );

    size_type tail_length = size( ) - pos;
    size_type erase_length = ( tail_length <= n ) ? tail_length : n;
    Traits::move( buffer + pos, buffer + pos + n, tail_length - erase_length );
    filled -= erase_length;
    return( *this );
  }

  // erase( iterator )
  // *****************
  template< class CharT, class Traits, class Allocator >
  inline
  typename basic_string< CharT, Traits, Allocator >::iterator
    basic_string< CharT, Traits, Allocator >::erase( iterator p )
  {
    erase( p - begin(), 1 );
    return( p );
  }

  // erase( iterator, iterator )
  // ***************************
  template< class CharT, class Traits, class Allocator >
  inline
  typename basic_string< CharT, Traits, Allocator >::iterator
    basic_string< CharT, Traits, Allocator >::erase(
      iterator first,
      iterator last )
  {
    erase( first - begin(), last - first);
    return( first );
  }

  // data( ) const
  // *************
  template< class CharT, class Traits, class Allocator >
  inline
  const CharT *basic_string< CharT, Traits, Allocator >::data( ) const
  {
    // Problematic if 'pointer' is an unusual type.
    return( buffer );
  }

  // ======================================
  // Ordinary functions using basic_string.
  // ======================================

  // operator+( const basic_string &, const basic_string & )
  // +++++++++++++++++++++++++++++++++++++++++++++++++++++++
  template< class CharT, class Traits, class Allocator >
  basic_string< CharT, Traits, Allocator >
    operator+( const basic_string< CharT, Traits, Allocator > &left,
               const basic_string< CharT, Traits, Allocator > &right )
  {
    basic_string< CharT, Traits, Allocator > temp(left);
    temp += right;
    return( temp );
  }

  // operator+( const CharT *, const basic_string & )
  // ++++++++++++++++++++++++++++++++++++++++++++++++
  template< class CharT, class Traits, class Allocator >
  basic_string< CharT, Traits, Allocator >
    operator+( const CharT *left,
               const basic_string< CharT, Traits, Allocator > &right )
  {
    basic_string< CharT, Traits, Allocator > temp(left);
    temp += right;
    return( temp );
  }

  // operator+( const basic_string &, const CharT * )
  // ++++++++++++++++++++++++++++++++++++++++++++++++
  template< class CharT, class Traits, class Allocator >
  basic_string< CharT, Traits, Allocator >
    operator+( const basic_string< CharT, Traits, Allocator > &left,
               const CharT *right )
  {
    basic_string< CharT, Traits, Allocator > temp(left);
    temp += right;
    return( temp );
  }

  // operator+( CharT, const basic_string & )
  // ++++++++++++++++++++++++++++++++++++++++
  template< class CharT, class Traits, class Allocator >
  basic_string< CharT, Traits, Allocator >
    operator+( CharT left,
               const basic_string< CharT, Traits, Allocator > &right )
  {
    basic_string< CharT, Traits, Allocator > temp(1, left);
    temp += right;
    return( temp );
  }

  // operator+( const basic_string &, CharT )
  // ++++++++++++++++++++++++++++++++++++++++
  template< class CharT, class Traits, class Allocator >
  basic_string< CharT, Traits, Allocator >
    operator+( const basic_string< CharT, Traits, Allocator > &left,
               CharT right )
  {
    basic_string< CharT, Traits, Allocator > temp(left);
    temp += right;
    return( temp );
  }

  // operator==( const basic_string &, const basic_string & )
  // ++++++++++++++++++++++++++++++++++++++++++++++++++++++++
  template< class CharT, class Traits, class Allocator >
  bool operator==( const basic_string< CharT, Traits, Allocator > &left,
                   const basic_string< CharT, Traits, Allocator > &right )
  {
    if( left.filled != right.filled ) return false;
    return( Traits::compare( left.buffer, right.buffer, left.filled ) == 0 );
  }

  // operator==( const CharT *, const basic_string & )
  // +++++++++++++++++++++++++++++++++++++++++++++++++
  template< class CharT, class Traits, class Allocator >
  bool operator==( const CharT *left,
                   const basic_string< CharT, Traits, Allocator > &right )
  {
    if( Traits::length( left ) != right.filled ) return false;
    return( Traits::compare( left, right.buffer, right.filled ) == 0 );
  }

  // operator==( const basic_string &, const CharT * )
  // +++++++++++++++++++++++++++++++++++++++++++++++++
  template< class CharT, class Traits, class Allocator >
  bool operator==( const basic_string< CharT, Traits, Allocator > &left,
                   const CharT *right )
  {
    if( left.filled != Traits::length( right ) ) return false;
    return( Traits::compare( left.buffer, right, left.filled ) == 0 );
  }

  // operator!=( const basic_string &, const basic_string & )
  // ++++++++++++++++++++++++++++++++++++++++++++++++++++++++
  template< class CharT, class Traits, class Allocator >
  inline
  bool operator!=( const basic_string< CharT, Traits, Allocator > &left,
                   const basic_string< CharT, Traits, Allocator > &right )
  {
    return( !( left == right ) );
  }

  // operator!=( const CharT *, const basic_string & )
  // +++++++++++++++++++++++++++++++++++++++++++++++++
  template< class CharT, class Traits, class Allocator >
  inline
  bool operator!=( const CharT *left,
                   const basic_string< CharT, Traits, Allocator > &right )
  {
    return( !( left == right ) );
  }

  // operator!=( const basic_string &, const CharT * )
  // +++++++++++++++++++++++++++++++++++++++++++++++++
  template< class CharT, class Traits, class Allocator >
  inline
  bool operator!=( const basic_string< CharT, Traits, Allocator > &left,
                   const CharT *right )
  {
    return( !( left == right ) );
  }

  // operator<( const basic_string &, const basic_string & )
  // +++++++++++++++++++++++++++++++++++++++++++++++++++++++
  template< class CharT, class Traits, class Allocator >
  bool operator<( const basic_string< CharT, Traits, Allocator > &left,
                  const basic_string< CharT, Traits, Allocator > &right )
  {
    Allocator::size_type common_length = left.filled;
    if( right.filled < common_length ) common_length = right.filled;
    int result = Traits::compare( left.buffer, right.buffer, common_length );
    if( result < 0 ) return true;
    if( result == 0 && left.filled < right.filled ) return true;
    return( false );
  }

  // operator<( const CharT *, const basic_string & )
  // ++++++++++++++++++++++++++++++++++++++++++++++++
  template< class CharT, class Traits, class Allocator >
  bool operator<( const CharT *left,
                  const basic_string< CharT, Traits, Allocator > &right )
  {
    Allocator::size_type raw_length = Traits::length( left );
    Allocator::size_type common_length = raw_length;
    if( right.filled < common_length ) common_length = right.filled;
    int result = Traits::compare( left, right.buffer, common_length );
    if( result < 0 ) return true;
    if( result == 0 && raw_length < right.filled ) return true;
    return( false );
  }

  // operator<( const basic_string &, const CharT * )
  // ++++++++++++++++++++++++++++++++++++++++++++++++
  template< class CharT, class Traits, class Allocator >
  bool operator<( const basic_string< CharT, Traits, Allocator > &left,
                  const CharT *right )
  {
    Allocator::size_type raw_length = Traits::length( right );
    Allocator::size_type common_length = left.filled;
    if( raw_length < common_length ) common_length = raw_length;
    int result = Traits::compare( left.buffer, right, common_length );
    if( result < 0 ) return true;
    if( result == 0 && left.filled < raw_length ) return true;
    return( false );
  }

  // operator>( const basic_string &, const basic_string & )
  // +++++++++++++++++++++++++++++++++++++++++++++++++++++++
  template< class CharT, class Traits, class Allocator >
  inline
  bool operator>( const basic_string< CharT, Traits, Allocator > &left,
                  const basic_string< CharT, Traits, Allocator > &right )
  {
    return( right < left );
  }

  // operator>( const CharT *, const basic_string & )
  // ++++++++++++++++++++++++++++++++++++++++++++++++
  template< class CharT, class Traits, class Allocator >
  inline
  bool operator>( const CharT *left,
                  const basic_string< CharT, Traits, Allocator > &right )
  {
    return( right < left );
  }

  // operator>( const basic_string &, const CharT * )
  // ++++++++++++++++++++++++++++++++++++++++++++++++
  template< class CharT, class Traits, class Allocator >
  inline
  bool operator>( const basic_string< CharT, Traits, Allocator > &left,
                  const CharT *right )
  {
    return( right < left );
  }

  // operator<=( const basic_string &, const basic_string & )
  // ++++++++++++++++++++++++++++++++++++++++++++++++++++++++
  template< class CharT, class Traits, class Allocator >
  inline
  bool operator<=( const basic_string< CharT, Traits, Allocator > &left,
                   const basic_string< CharT, Traits, Allocator > &right )
  {
    return( !( left > right ) );
  }

  // operator<=( const CharT *, const basic_string & )
  // +++++++++++++++++++++++++++++++++++++++++++++++++
  template< class CharT, class Traits, class Allocator >
  inline
  bool operator<=( const CharT *left,
                   const basic_string< CharT, Traits, Allocator > &right )
  {
    return( !( left > right ) );
  }

  // operator<=( const basic_string &, const CharT * )
  // +++++++++++++++++++++++++++++++++++++++++++++++++
  template< class CharT, class Traits, class Allocator >
  inline
  bool operator<=( const basic_string< CharT, Traits, Allocator > &left,
                   const CharT *right )
  {
    return( !( left > right ) );
  }

  // operator>=( const basic_string &, const basic_string & )
  // ++++++++++++++++++++++++++++++++++++++++++++++++++++++++
  template< class CharT, class Traits, class Allocator >
  inline
  bool operator>=( const basic_string< CharT, Traits, Allocator > &left,
                   const basic_string< CharT, Traits, Allocator > &right )
  {
    return( !( left < right ) );
  }

  // operator>=( const CharT *, const basic_string & )
  // +++++++++++++++++++++++++++++++++++++++++++++++++
  template< class CharT, class Traits, class Allocator >
  inline
  bool operator>=( const CharT *left,
                   const basic_string< CharT, Traits, Allocator > &right )
  {
    return( !( left < right ) );
  }

  // operator>=( const basic_string &, const CharT * )
  // +++++++++++++++++++++++++++++++++++++++++++++++++
  template< class CharT, class Traits, class Allocator >
  inline
  bool operator>=( const basic_string< CharT, Traits, Allocator > &left,
                   const CharT *right )
  {
    return( !( left < right ) );
  }

  // swap( basic_string &, basic_string & )
  // ++++++++++++++++++++++++++++++++++++++
  template< class CharT, class Traits, class Allocator >
  void swap(
      basic_string< CharT, Traits, Allocator > &left,
      basic_string< CharT, Traits, Allocator > &right )
  {
    typename Allocator::pointer ptemp;
    typename Allocator::size_type stemp;

    ptemp        = left.buffer;
    left.buffer  = right.buffer;
    right.buffer = ptemp;

    stemp        = left.total;
    left.total   = right.total;
    right.total  = stemp;

    stemp        = left.filled;
    left.filled  = right.filled;
    right.filled = stemp;
  }

} // namespace std

#endif
:endsegment
