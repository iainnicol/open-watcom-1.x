///////////////////////////////////////////////////////////////////////////
// FILE: functional (Functional templates)
//
:keep CPP_HDR
:include crwat.sp
//
// Description: This header is part of the C++ standard library. It
//              defines a number of functional-like templates and 
//              associated binders and adaptors.
///////////////////////////////////////////////////////////////////////////
#ifndef _FUNCTIONAL_INCLUDED
#define _FUNCTIONAL_INCLUDED

:include readonly.sp

#ifndef __cplusplus
#error The header functional requires C++
#endif

#define typename

namespace std {

  template< class Arg1, class Result >
  struct unary_function {
    typedef Arg1   argument_type;
    typedef Result result_type;
  };


  template< class Arg1, class Arg2, class Result >
  struct binary_function {
    typedef Arg1   first_argument_type;
    typedef Arg2   second_argument_type;
    typedef Result result_type;
  };


  template< class T >
  struct plus : binary_function< T, T, T > {
    T operator( )( const T &x, const T &y ) const
      { return( x + y ); }
  };


  template< class T >
  struct minus : binary_function< T, T, T > {
    T operator( )( const T &x, const T &y ) const
      { return( x - y ); }
  };


  template< class T >
  struct multiplies : binary_function< T, T, T > {
    T operator( )( const T &x, const T &y ) const
      { return( x * y ); }
  };


  template< class T >
  struct divides : binary_function< T, T, T > {
    T operator( )( const T &x, const T &y ) const
      { return( x / y ); }
  };


  template< class T >
  struct modulus : binary_function< T, T, T > {
    T operator( )( const T &x, const T &y ) const
      { return( x % y ); }
  };


  template< class T >
  struct negate : unary_function< T, T > {
    T operator( )( const T &x ) const
      { return( -x ); }
  };


  template< class T >
  struct equal_to : binary_function< T, T, bool > {
    T operator( )( const T &x, const T &y ) const
      { return( x == y ); }
  };


  template< class T >
  struct not_equal_to : binary_function< T, T, bool > {
    T operator( )( const T &x, const T &y ) const
      { return( x != y ); }
  };


  template< class T >
  struct greater : binary_function< T, T, bool > {
    T operator( )( const T &x, const T &y ) const
      { return( x > y ); }
  };


  template< class T >
  struct less : binary_function< T, T, bool > {
    T operator( )( const T &x, const T &y ) const
      { return( x < y ); }
  };


  template< class T >
  struct greater_equal : binary_function< T, T, bool > {
    T operator( )( const T &x, const T &y ) const
      { return( x >= y ); }
  };


  template< class T >
  struct less_equal : binary_function< T, T, bool > {
    T operator( )( const T &x, const T &y ) const
      { return( x <= y ); }
  };


  template< class T >
  struct logical_and : binary_function< T, T, bool > {
    T operator( )( const T &x, const T &y ) const
      { return( x && y ); }
  };


  template< class T >
  struct logical_or : binary_function< T, T, bool > {
    T operator( )( const T &x, const T &y ) const
      { return( x || y ); }
  };


  template< class T >
  struct logical_not : unary_function< T, bool > {
    T operator( )( const T &x ) const
      { return( !x ); }
  };


  template< class Predicate >
  class unary_negate : public
    unary_function< typename Predicate::argument_type, bool > {
    const Predicate &pred;
  public:
    explicit unary_negate( const Predicate &p ) : pred( p ) { }
    bool operator( )( const typename Predicate::argument_type &x ) const
      { return( !pred( x ) ); }
  };


  template< class Predicate >
  inline unary_negate< Predicate > not1( const Predicate &p )
    { return( unary_negate< Predicate >( p ) ); }


  template< class Predicate >
  class binary_negate : public
    binary_function< typename Predicate::first_argument_type,
                     typename Predicate::second_argument_type, 
                     bool > {
    const Predicate &pred;
  public:
    explicit binary_negate( const Predicate &p ) : pred( p ) { }
    bool operator( )( const typename Predicate::first_argument_type  &x,
                      const typename Predicate::second_argument_type &y ) const
      { return( !pred( x, y ) ); }
  };


  template< class Predicate >
  inline binary_negate< Predicate > not2( const Predicate &p )
    { return( binary_negate< Predicate >( p ) ); }


  template< class Operation >
  class binder1st : public
    unary_function< typename Operation::second_argument_type,
                    typename Operation::result_type > {
  protected:
    Operation op;
    typename Operation::first_argument_type value;
  public:
    binder1st( const Operation &x,
               const typename Operation::first_argument_type &y ) 
      : op( x ), value( y ) { }
    typename Operation::result_type
      operator( )( const typename Operation::second_argument_type &x ) const
      { return( op( value, x ) ); }
  };


  template< class Operation, class T >
  inline binder1st< Operation > bind1st( const Operation &x, const T &y )
    { return( binder1st< Operation >(
                x, typename Operation::first_argument_type( y ) ) ); }


  template< class Operation >
  class binder2nd : public
    unary_function< typename Operation::first_argument_type,
                    typename Operation::result_type > {
  protected:
    Operation op;
    typename Operation::second_argument_type value;
  public:
    binder2nd( const Operation &x,
               const typename Operation::second_argument_type &y ) 
      : op( x ), value( y ) { }
    typename Operation::result_type
      operator( )( const typename Operation::first_argument_type &x ) const
      { return( op( x, value ) ); }
  };


  template< class Operation, class T >
  inline binder2nd< Operation > bind2nd( const Operation &x, const T &y )
    { return( binder2nd< Operation >(
                x, typename Operation::second_argument_type( y ) ) ); }


  template< class Arg1, class Result >
  class pointer_to_unary_function : public
    unary_function< Arg1,
                    Result > {
    Result ( *p )( Arg1 );
  public:
    explicit pointer_to_unary_function( Result ( *f )( Arg1 ) )
      : p( f ) { }
    Result operator( )( Arg1 x ) const
      { return( p( x ) ); }
  };


  template< class Arg1, class Arg2, class Result >
  class pointer_to_binary_function : public
    binary_function< Arg1,
                     Arg2,
                     Result > {
    Result ( *p )( Arg1, Arg2 );
  public:
    explicit pointer_to_binary_function( Result ( *f )( Arg1, Arg2 ) )
      : p( f ) { }
    Result operator( )( Arg1 x, Arg2 y ) const
      { return( p( x, y ) ); }
  };


  template< class Arg1, class Result >
  inline pointer_to_unary_function< Arg1, Result >
    ptr_fun( Result ( *f )( Arg1 ) )
    { return( pointer_to_unary_function< Arg1, Result >( f ) ); }


  template< class Arg1, class Arg2, class Result >
  inline pointer_to_binary_function< Arg1, Arg2, Result >
    ptr_fun( Result ( *f )( Arg1, Arg2 ) )
    { return( pointer_to_binary_function< Arg1, Arg2, Result >( f ) ); }


  template< class S, class T >
  class mem_fun_t : public unary_function< T*, S > {
    S ( T::*p )( );
  public:
    explicit mem_fun_t( S ( T::*f )( ) ) : p( f ) { }
    S operator( )( T *x ) const
      { return( ( x->*p )( ) ); }
  };


  template< class S, class T, class A >
  class mem_fun1_t : public binary_function< T*, A, S > {
    S ( T::*p )( A );
  public:
    explicit mem_fun1_t( S ( T::*f )( A ) ) : p( f ) { }
    S operator( )( T *x, A y ) const
      { return( ( x->*p )( y ) ); }
  };


  template< class S, class T >
  inline mem_fun_t< S, T > mem_fun( S ( T::*f )( ) )
    { return( mem_fun_t< S, T >( f ) ); }


  template< class S, class T, class A >
  inline mem_fun1_t< S, T, A > mem_fun( S ( T::*f )( A ) )
    { return( mem_fun1_t< S, T, A >( f ) ); }


  template< class S, class T >
  class mem_fun_ref_t : public unary_function< T, S > {
    S ( T::*p )( );
  public:
    explicit mem_fun_ref_t( S ( T::*f )( ) ) : p( f ) { }
    S operator( )( T &x ) const
      { return( ( x.*p )( ) ); }
  };


  template< class S, class T, class A >
  class mem_fun1_ref_t : public binary_function< T, A, S > {
    S ( T::*p )( A );
  public:
    explicit mem_fun1_ref_t( S ( T::*f )( A ) ) : p( f ) { }
    S operator( )( T &x, A y ) const
      { return( ( x.*p )( y ) ); }
  };


  template< class S, class T >
  inline mem_fun_ref_t< S, T > mem_fun_ref( S ( T::*f )( ) )
    { return( mem_fun_ref_t< S, T >( f ) ); }


  template< class S, class T, class A >
  inline mem_fun1_ref_t< S, T, A > mem_fun_ref( S ( T::*f )( A ) )
    { return( mem_fun1_ref_t< S, T, A >( f ) ); }


  template< class S, class T >
  class const_mem_fun_t : public unary_function< const T*, S > {
    S ( T::*p )( ) const;
  public:
    explicit const_mem_fun_t( S ( T::*f )( ) const ) : p( f ) { }
    S operator( )( const T *x ) const
      { return( ( x->*p )( ) ); }
  };


  template< class S, class T, class A >
  class const_mem_fun1_t : public binary_function< const T*, A, S > {
    S ( T::*p )( A ) const;
  public:
    explicit const_mem_fun1_t( S ( T::*f )( A ) const ) : p( f ) { }
    S operator( )( const T *x, A y ) const
      { return( ( x->*p )( y ) ); }
  };


  template< class S, class T >
  inline const_mem_fun_t< S, T > mem_fun( S ( T::*f )( ) const )
    { return( const_mem_fun_t< S, T >( f ) ); }


  template< class S, class T, class A >
  inline const_mem_fun1_t< S, T, A > mem_fun( S ( T::*f )( A ) const )
    { return( const_mem_fun1_t< S, T, A >( f ) ); }


  template< class S, class T >
  class const_mem_fun_ref_t : public unary_function< T, S > {
    S ( T::*p )( ) const;
  public:
    explicit const_mem_fun_ref_t( S ( T::*f )( ) const ) : p( f ) { }
    S operator( )( const T &x ) const
      { return( ( x.*p )( ) ); }
  };


  template< class S, class T, class A >
  class const_mem_fun1_ref_t : public binary_function< T, A, S > {
    S ( T::*p )( A ) const;
  public:
    explicit const_mem_fun1_ref_t( S ( T::*f )( A ) const ) : p( f ) { }
    S operator( )( const T &x, A y ) const
      { return( ( x.*p )( y ) ); }
  };


  template< class S, class T >
  inline const_mem_fun_ref_t< S, T > mem_fun_ref( S ( T::*f )( ) const )
    { return( const_mem_fun_ref_t< S, T >( f ) ); }


  template< class S, class T, class A >
  inline const_mem_fun1_ref_t< S, T, A > mem_fun_ref( S ( T::*f )( A ) const )
    { return( const_mem_fun1_ref_t< S, T, A >( f ) ); }


} // End of namespace std.

#endif
