///////////////////////////////////////////////////////////////////////////
// FILE: vector (Definition of std::vector)
//
:keep CPP_HDR
:include crwat.sp
//
// Description: This header is part of the C++ standard library.
///////////////////////////////////////////////////////////////////////////
#ifndef _VECTOR_INCLUDED
#define _VECTOR_INCLUDED

:include readonly.sp

#ifndef __cplusplus
#error The header vector requires C++
#endif

#include <iterator>
#include <memory>
#include <stdexcept>

#define typename

namespace std {

  template<class Type, class Allocator = allocator< Type > >
  class vector {
  public:
    typedef typename Allocator::reference       reference;
    typedef typename Allocator::const_reference const_reference;
    typedef typename Allocator::size_type       size_type;
    typedef typename Allocator::difference_type difference_type;
    typedef Type                                value_type;
    typedef Allocator                           allocator_type;
    typedef typename Allocator::pointer         pointer;
    typedef typename Allocator::const_pointer   const_pointer;

    typedef pointer iterator;
    typedef const_pointer const_iterator;

    // typedef reverse_iterator<iterator>        reverse_iterator;
    // typedef reverse_iterator<const_iterator>  const_reverse_iterator;

    explicit vector( const Allocator & = Allocator( ) );
    explicit vector( size_type n, const Type &value = Type( ), const Allocator & = Allocator( ) );
    vector( const vector &other );
   ~vector( );
    vector &operator=( const vector &other );
    void assign( size_type n, const Type &value );
    allocator_type get_allocator( ) const;

    iterator               begin( );
    const_iterator         begin( ) const;
    iterator               end( );
    const_iterator         end( ) const;
    // reverse_iterator       rbegin( );
    // const_reverse_iterator rbegin( ) const;
    // reverse_iterator       rend( );
    // const_reverse_iterator rend( ) const;

    size_type size( ) const;
    size_type max_size( ) const;
    void      resize( size_type sz, Type c = Type( ) );
    size_type capacity( ) const;
    bool      empty( ) const;
    void      reserve( size_type n );

    reference       operator[]( size_type n );
    const_reference operator[]( size_type n ) const;
    reference       at( size_type n );
    const_reference at( size_type n ) const;
    reference       front( );
    const_reference front( ) const;
    reference       back( );
    const_reference back( ) const;

    void     push_back( const Type &x );
    void     pop_back( );
    iterator insert( iterator position, const Type &x );
    void     insert( iterator position, size_type n, const Type&x );
    iterator erase( iterator position );
    iterator erase( iterator first, iterator last );
    void     swap( vector &x );
    void     clear( );

  private:
    // 1. buffer has size total.
    // 2. buffer never shrinks.
    // 3. total >= filled.
    // 4. total is a power of two.
    // 5. buffer allocated with mem or a copy of mem.
    //
    Allocator mem;      // Object used to get and release memory.
    pointer   buffer;   // Pointer to start of buffer space.
    size_type filled;   // Number of buffer slots in use by objects.
    size_type total;    // Total number of buffer slots.

    // This method encapsulates the memory allocation policy.
    pointer alloc( size_type required, size_type &found );

    // Doubles size of buffer and copies objects from old to new.
    void realloc( );
  };

  // ==========================
  // Member functions of vector
  // ==========================

  template< class Type, class Allocator >
  vector< Type, Allocator >::pointer
    vector< Type, Allocator >::alloc(
      size_type required,
      size_type &found )
  {
    pointer   result;
    size_type length = 16;

    // Find a power of two that produces a sufficient size.
    while( length < required ) length <<= 1;
    result = mem.allocate( length );

    // Update outputs only if allocation successful.
    found = length;
    return( result );
  }

  // realloc( )
  // **********
  template< class Type, class Allocator >
  void vector< Type, Allocator >::realloc( )
  {
    size_type temp_total = ( total << 1 );  // Check for overflow?
    pointer temp = mem.allocate( temp_total );
    try {
      uninitialized_copy( buffer, buffer + filled, temp );
    }
    catch( ... ) {
      mem.deallocate( temp, temp_total );
      throw;
    }

    // New allocation successful. Remove old vector and commit to new.
    pointer start = buffer;
    while( buffer < start + filled ) {
      buffer->~Type( );
      ++buffer;
    }
    total  = temp_total;
    buffer = temp;
  }

  // vector( const Allocator & )
  // ***************************
  template< class Type, class Allocator >
  vector< Type, Allocator >::vector( const Allocator &a ) : mem( a )
  {
    buffer = alloc(1, total );
    filled = 0;
  }

  // vector( size_type, const Type &, const Allocator & )
  //*****************************************************
  template< class Type, class Allocator >
  vector< Type, Allocator >::vector(
    size_type n,
    const Type &value,
    const Allocator &a ) : mem( a )
  {
    buffer = alloc( n, total );
    try {
      uninitialized_fill_n( buffer, n, value );
    }
    catch( ... ) {
      mem.deallocate( buffer, total );
      throw;
    }
    filled = n;
  }

  // vector( const vector & )
  // ************************
  template< class Type, class Allocator >
  vector< Type, Allocator >::vector( const vector &other )
    : mem( other.mem )
  {
    buffer = alloc( other.filled, total );
    try {
      uninitialized_copy( other.buffer,
                          other.buffer + other.filled,
                          buffer );
    }
    catch( ... ) {
      mem.deallocate( buffer, total );
      throw;
    }
    filled = other.filled;
  }

  // ~vector( )
  // **********
  template< class Type, class Allocator >
  vector< Type, Allocator >::~vector( )
  {
    // Delete objects actually in use and deallocate the total buffer.
    for( size_type i = 0; i < filled; ++i ) {
      mem.destroy( &buffer[i] );
    }
    mem.deallocate( buffer, total );
  }

  // operator=( const vector & )
  // ***************************
  template< class Type, class Allocator >
  vector< Type, Allocator > &vector< Type, Allocator >::operator=(
    const vector &other )
  {
    if( this == &other ) return *this;

    // Don't overwrite our allocator just yet.
    Allocator temp_allocator( other.mem );

    // Allocate buffer space for copy and try to make the copy.
    pointer temp = temp_allocator.allocate( other.total );
    try {
      uninitialized_copy( other.buffer,
                          other.buffer + other.filled,
                          temp );
    }
    catch( ... ) {
      mem.deallocate( temp, other.total );
      throw;
    }

    // If we get here with no exception, remove the existing value.
    for( size_type i = 0; i < filled; ++i ) {
      mem.destroy( &buffer[i] );
    }
    mem.deallocate( buffer, total );

    // Commit the new value.
    mem    = temp_allocator;
    total  = other.total;
    buffer = temp;
    filled = other.filled;

    return( *this );
  }

  // assign( size_type, const Type & )
  // *********************************
  template< class Type, class Allocator >
  void vector< Type, Allocator >::assign( size_type n, const Type &value )
  {
    // Prepare new buffer space.
    size_type temp_total;
    pointer temp = alloc( n, temp_total );
    try {
      uninitialized_fill_n( temp, n, value );
    }
    catch( ... ) {
      mem.deallocate( temp, temp_total );
      throw;
    }

    // If we get here with no exception, remove the existing value.
    for( size_type i = 0; i < filled; ++i ) {
      mem.destroy( &buffer[i] );
    }
    mem.deallocate( buffer, total );

    // Commit the new value.
    total  = temp_total;
    buffer = temp;
    filled = n;
  }

  // get_allocator( ) const
  // **********************
  template< class Type, class Allocator >
  inline
  typename vector< Type, Allocator >::allocator_type
    vector<Type, Allocator>::get_allocator( ) const
  {
    return( mem );
  }

  // begin( )
  // ********
  template< class Type, class Allocator >
  inline
  typename vector< Type, Allocator >::iterator
    vector<Type, Allocator>::begin( )
  {
    return( buffer );
  }

  // begin( ) const
  // **************
  template< class Type, class Allocator >
  inline
  typename vector< Type, Allocator >::const_iterator
    vector<Type, Allocator>::begin( ) const
  {
    return( buffer );
  }

  // end( )
  // ******
  template< class Type, class Allocator >
  inline
  typename vector< Type, Allocator >::iterator
    vector< Type, Allocator >::end( )
  {
    return( buffer + filled );
  }

  // end( ) const
  // ************
  template< class Type, class Allocator >
  inline
  typename vector< Type, Allocator >::const_iterator
    vector< Type, Allocator >::end( ) const
  {
    return( buffer + filled );
  }

  // size( ) const
  // *************
  template< class Type, class Allocator >
  inline
  typename vector< Type, Allocator >::size_type
    vector< Type, Allocator >::size( ) const
  {
    return( filled );
  }

  // capacity( ) const
  // *****************
  template< class Type, class Allocator >
  inline
  typename vector< Type, Allocator >::size_type
    vector< Type, Allocator >::capacity( ) const
  {
    return( total );
  }

  // empty( ) const
  // **************
  template< class Type, class Allocator >
  inline
  bool vector< Type, Allocator >::empty( ) const
  {
    return( filled == 0 );
  }

  // operator[]( size_type )
  // ***********************
  template< class Type, class Allocator >
  inline
  typename vector< Type, Allocator >::reference
    vector< Type, Allocator >::operator[]( size_type n )
  {
    return( buffer[n] );
  }

  // operator[]( size_type ) const
  // *****************************
  template< class Type, class Allocator >
  inline typename vector< Type, Allocator >::const_reference
    vector< Type, Allocator >::operator[]( size_type n ) const
  {
    return( buffer[n] );
  }

  // at( size_type )
  // ***************
  template< class Type, class Allocator >
  typename vector< Type, Allocator >::reference
    vector< Type, Allocator >::at( size_type n )
  {
    if( n >= filled )
      throw out_of_range( "vector::at" );
    return( buffer[n] );
  }

  // at( size_type ) const
  // *********************
  template< class Type, class Allocator >
  typename vector< Type, Allocator >::const_reference
    vector< Type, Allocator >::at( size_type n ) const
  {
    if( n >= filled )
      throw out_of_range( "vector::at" );
    return( buffer[n] );
  }

  // front( )
  // ********
  template< class Type, class Allocator >
  inline
  typename vector< Type, Allocator >::reference
    vector< Type, Allocator >::front( )
  {
    return( buffer[0] );
  }

  // front( ) const
  // **************
  template< class Type, class Allocator >
  inline
  typename vector< Type, Allocator >::const_reference
    vector< Type, Allocator >::front( ) const
  {
    return( buffer[0] );
  }

  // back( )
  // *******
  template< class Type, class Allocator >
  inline
  typename vector< Type, Allocator >::reference
    vector< Type, Allocator >::back( )
  {
    return( buffer[filled - 1] );
  }

  // back( ) const
  // *************
  template< class Type, class Allocator >
  inline
  typename vector< Type, Allocator >::const_reference
    vector< Type, Allocator >::back( ) const
  {
    return( buffer[filled - 1] );
  }

  // push_back( const Type & )
  // *************************
  template< class Type, class Allocator >
  void vector< Type, Allocator >::push_back( const Type &item )
  {
    if( filled + 1 > total ) {
      realloc( );
    }
    new ( static_cast<void *>( buffer + filled ) ) Type( item );
    ++filled;
  }

  // pop_back( )
  // ***********
  template< class Type, class Allocator >
  inline void vector< Type, Allocator >::pop_back( )
  {
    mem.destroy( &buffer[filled - 1] );
    --filled;
  }

  // swap( )
  // *******
  template< class Type, class Allocator >
  void vector< Type, Allocator >::swap( vector &vec )
  {
    typename Allocator::pointer ptemp;
    typename Allocator::size_type stemp;
    Allocator atemp;

    ptemp      = buffer;
    buffer     = vec.buffer;
    vec.buffer = ptemp;

    stemp      = total;
    total      = vec.total;
    vec.total  = stemp;

    stemp      = filled;
    filled     = vec.filled;
    vec.filled = stemp;

    atemp      = mem;
    mem        = vec.mem;
    vec.mem    = atemp;
  }

  // clear( )
  // ********
  template< class Type, class Allocator >
  void vector< Type, Allocator >::clear( )
  {
    // Delete objects actually in use and deallocate the total buffer.
    for( size_type i = 0; i < filled; ++i ) {
      mem.destroy( &buffer[i] );
    }

    // Rebuild buffer (this is only place where vector capacity might shrink).
    mem.deallocate( buffer, total );
    buffer = alloc(1, total );  // Might throw. Problem?
    filled = 0;
  }

  // ===============================
  // Ordinary functions using vector
  // ===============================

  // operator==( const vector &, const vector & )
  // ++++++++++++++++++++++++++++++++++++++++++++
  template< class Type, class Allocator >
  bool operator==(
    const vector< Type, Allocator > &x,
    const vector< Type, Allocator > &y )
  {
    if( x.size( ) != y.size( ) ) return( false );

    vector< Type, Allocator>::size_type index = 0;
    while( index < x.size( ) ) {
      if( x[index] != y[index] ) return( false );
      ++index;
    }
    return( true );
  }

  // operator!=( const vector &, const vector & )
  // ++++++++++++++++++++++++++++++++++++++++++++
  template< class Type, class Allocator >
  inline
  bool operator!=(
    const vector< Type, Allocator > &x,
    const vector< Type, Allocator > &y )
  {
    return( !(x == y) );
  }

  // operator<( const vector &, const vector & )
  // +++++++++++++++++++++++++++++++++++++++++++
  template< class Type, class Allocator >
  bool operator<(
    const vector< Type, Allocator > &x,
    const vector< Type, Allocator > &y )
  {
    vector< Type, Allocator>::size_type index = 0;
    while( index != x.size( ) && index != y.size( ) ) {
      if( x[index] < y[index] ) return( true );
      if( y[index] < x[index] ) return( false );
      ++index;
    }
    return( index == x.size( ) && index != y.size( ) );
  }

  // operator<=( const vector &, const vector & )
  // ++++++++++++++++++++++++++++++++++++++++++++
  template< class Type, class Allocator >
  inline
  bool operator<=(
    const vector< Type, Allocator > &x,
    const vector< Type, Allocator > &y )
  {
    return( !( x > y) );
  }

  // operator>( const vector &, const vector & )
  // +++++++++++++++++++++++++++++++++++++++++++
  template< class Type, class Allocator >
  inline
  bool operator>(
    const vector< Type, Allocator > &x,
    const vector< Type, Allocator > &y )
  {
    return( y < x);
  }

  // operator>=( const vector &, const vector & )
  // ++++++++++++++++++++++++++++++++++++++++++++
  template< class Type, class Allocator >
  inline
  bool operator>=(
    const vector< Type, Allocator > &x,
    const vector< Type, Allocator > &y )
  {
    return( !(x < y) );
  }

  // Vector swap ambiguous if general swap (in algorithm) visible.
  // Need partial ordering of function templates for this to work.
  //
  #ifdef __NEVER
  // swap( vector &, vector & )
  // ++++++++++++++++++++++++++
  template< class Type, class Allocator >
  inline
  void swap( vector< Type, Allocator > &x, vector< Type, Allocator > &y )
  {
    x.swap( y );
  }
  #endif

} // End of namespace std.

#endif
