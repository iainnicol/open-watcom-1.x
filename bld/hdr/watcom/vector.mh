///////////////////////////////////////////////////////////////////////////
// FILE: vector (...)
//
:keep CPP_HDR
:include crwat.sp
//
// Description: This header is part of the C++ standard library.
///////////////////////////////////////////////////////////////////////////
#ifndef _VECTOR_INCLUDED
#define _VECTOR_INCLUDED

:include readonly.sp

#ifndef __cplusplus
#error The header vector requires C++
#endif

#include <iterator>
#include <memory>
#include <stdexcept>

#define typename

namespace std {

  template<class Type, class Allocator = allocator< Type > >
  class vector {
  public:
    typedef typename Allocator::reference       reference;
    typedef typename Allocator::const_reference const_reference;
    typedef typename Allocator::size_type       size_type;
    typedef typename Allocator::difference_type difference_type;
    typedef Type                                value_type;
    typedef Allocator                           allocator_type;
    typedef typename Allocator::pointer         pointer;
    typedef typename Allocator::const_pointer   const_pointer;

    // typedef pointer iterator;
    //
    class iterator : public std::iterator<
      random_access_iterator_tag, Type, difference_type, pointer, reference > {
    public:

      iterator( )
        { }

      iterator( pointer p ) : ptr( p )
        { }

      reference operator *( ) const
        { return( *ptr ); }

      // pointer operator->( ) const
      //   { return( ptr ); }

      reference operator[]( size_type index ) const
        { return( ptr[index] ); }

      iterator &operator+=( difference_type delta )
        { ptr += delta; return( *this ); }

      iterator &operator-=( difference_type delta )
        { ptr -= delta; return( *this ); }

      iterator &operator++( )
        { ++ptr; return( *this ); }

      iterator &operator--( )
        { --ptr; return( *this ); }

      iterator  operator++( int )
        { iterator temp( *this ); ptr++; return( temp ); }

      iterator  operator--( int )
        { iterator temp( *this ); ptr--; return( temp ); }

      difference_type operator-( const iterator &other ) const
        { return( ptr - other.ptr ); }

      iterator operator+( difference_type delta )
        { iterator temp( *this ); temp.ptr += delta; return( temp ); }

      iterator operator-( difference_type delta )
        { iterator temp( *this ); temp.ptr -= delta; return( temp ); }

      bool operator==( const iterator &other ) const
        { return( ptr == other.ptr ); }

      bool operator!=( const iterator &other ) const
        { return( ptr != other.ptr ); }

      bool operator<=( const iterator &other ) const
        { return( ptr <= other.ptr ); }

      bool operator>=( const iterator &other ) const
        { return( ptr >= other.ptr ); }

      bool operator< ( const iterator &other ) const
        { return( ptr <  other.ptr ); }

      bool operator> ( const iterator &other ) const
        { return( ptr >  other.ptr ); }

    private:
      pointer ptr;
    };

    // typedef const_pointer const_iterator;

    // typedef reverse_iterator<iterator>        reverse_iterator;
    // typedef reverse_iterator<const_iterator>  const_reverse_iterator;

    explicit vector( const Allocator & = Allocator( ) );
    explicit vector( size_type n, const Type &value = Type( ), const Allocator & = Allocator( ) );
    vector( const vector &other );
   ~vector( );
    vector &operator=( const vector &other );
    void assign( size_type n, const Type &value );
    allocator_type get_allocator( ) const;

    iterator               begin( );
    // const_iterator         begin( ) const;
    iterator               end( );
    // const_iterator         end( ) const;
    // reverse_iterator       rbegin( );
    // const_reverse_iterator rbegin( ) const;
    // reverse_iterator       rend( );
    // const_reverse_iterator rend( ) const;

    size_type size( ) const;
    size_type max_size( ) const;
    void      resize( size_type sz, Type c = Type( ) );
    size_type capacity( ) const;
    bool      empty( ) const;
    void      reserve( size_type n );

    reference       operator[]( size_type n );
    const_reference operator[]( size_type n ) const;
    reference       at( size_type n );
    const_reference at( size_type n ) const;
    reference       front( );
    const_reference front( ) const;
    reference       back( );
    const_reference back( ) const;

    void     push_back( const Type &x );
    void     pop_back( );
    iterator insert( iterator position, const Type &x );
    void     insert( iterator position, size_type n, const Type&x );
    iterator erase( iterator position );
    iterator erase( iterator first, iterator last );
    void     swap( vector & );
    void     clear( );

  private:
    Allocator mem;      // Object used to get and release memory.
    pointer   buffer;   // Pointer to start of buffer space.
    size_type filled;   // Number of buffer slots in use by objects.
    size_type total;    // Total number of buffer slots.

    void reallocate( ); // Double the vector's capacity.
  };

  // ==========================
  // Member functions of vector
  // ==========================

  // vector( const Allocator & )
  // ***************************
  template< class Type, class Allocator >
  vector< Type, Allocator >::vector( const Allocator &a ) : mem( a )
  {
    total  = 4;
    buffer = mem.allocate( total );
    filled = 0;
  }

  // vector( size_type, const Type &, const Allocator & )
  //*****************************************************
  template< class Type, class Allocator >
  vector< Type, Allocator >::vector(
    size_type n,
    const Type &value,
    const Allocator &a ) : mem( a )
  {
    total = 4;
    while( total <= n ) total <<= 1;
    buffer = mem.allocate( total );
    try {
      uninitialized_fill_n( iterator( buffer ), n, value );
    }
    catch( ... ) {
      mem.deallocate( buffer, total );
      throw;
    }
    filled = n;
  }

  // vector( const vector & )
  // ************************
  template< class Type, class Allocator >
  vector< Type, Allocator >::vector( const vector &other )
  {
    mem    = other.mem;
    total  = other.total;
    buffer = mem.allocate( total );
    try {
      uninitialized_copy( iterator( other.buffer ),
                          iterator( other.buffer + other.filled ),
                          iterator( buffer ) );
    }
    catch( ... ) {
      mem.deallocate( buffer, total );
      throw;
    }
    filled = other.filled;
  }

  // ~vector( )
  // **********
  template< class Type, class Allocator >
  vector< Type, Allocator >::~vector( )
  {
    // Delete objects actually in use and deallocate the total buffer.
    for( size_type i = 0; i < filled; ++i ) {
      mem.destroy( &buffer[i] );
    }
    mem.deallocate( buffer, total );
  }

  // operator=( const vector & )
  // ***************************
  template< class Type, class Allocator >
  vector< Type, Allocator > &vector< Type, Allocator >::operator=(
    const vector &other )
  {
    if( this == &other ) return *this;

    // Don't overwrite our allocator just yet.
    Allocator temp_allocator( other.mem );

    // Allocate buffer space for copy and try to make the copy.
    pointer temp = temp_allocator.allocate( other.total );
    try {
      uninitialized_copy( iterator( other.buffer ),
                          iterator( other.buffer + other.filled ),
                          iterator( temp ) );
    }
    catch( ... ) {
      mem.deallocate( temp, other.total );
      throw;
    }

    // If we get here with no exception, remove the existing value.
    for( size_type i = 0; i < filled; ++i ) {
      mem.destroy( &buffer[i] );
    }
    mem.deallocate( buffer, total );

    // Commit the new value.
    mem    = temp_allocator;
    total  = other.total;
    buffer = temp;
    filled = other.filled;

    return( *this );
  }

  // assign( size_type, const Type & )
  // *********************************
  template< class Type, class Allocator >
  void vector< Type, Allocator >::assign( size_type n, const Type &value )
  {
    // Prepare new buffer space.
    size_type temp_total = 4;
    while( temp_total <= n ) temp_total <<= 1;
    pointer temp = mem.allocate( temp_total );
    try {
      uninitialized_fill_n( iterator( temp ), n, value );
    }
    catch( ... ) {
      mem.deallocate( temp, temp_total );
      throw;
    }

    // If we get here with no exception, remove the existing value.
    for( size_type i = 0; i < filled; ++i ) {
      mem.destroy( &buffer[i] );
    }
    mem.deallocate( buffer, total );

    // Commit the new value.
    total  = temp_total;
    buffer = temp;
    filled = n;
  }

  // get_allocator( ) const
  // **********************
  template< class Type, class Allocator >
  inline
  typename vector< Type, Allocator >::allocator_type
    vector<Type, Allocator>::get_allocator( ) const
  {
    return( mem );
  }

  // begin( )
  // ********
  template< class Type, class Allocator >
  inline
  typename vector< Type, Allocator >::iterator
    vector<Type, Allocator>::begin( )
  {
    return( iterator( buffer ) );
  }

  // end( )
  // ******
  template< class Type, class Allocator >
  inline
  typename vector< Type, Allocator >::iterator
    vector< Type, Allocator >::end( )
  {
    return( iterator( buffer + filled ) );
  }

  // size( ) const
  // *************
  template< class Type, class Allocator >
  inline
  typename vector< Type, Allocator >::size_type
    vector< Type, Allocator >::size( ) const
  {
    return( filled );
  }

  // capacity( ) const
  // *****************
  template< class Type, class Allocator >
  inline
  typename vector< Type, Allocator >::size_type
    vector< Type, Allocator >::capacity( ) const
  {
    return( total );
  }

  // empty( ) const
  // **************
  template< class Type, class Allocator >
  inline
  bool vector< Type, Allocator >::empty( ) const
  {
    return( filled == 0 );
  }

  // operator[]( size_type )
  // ***********************
  template< class Type, class Allocator >
  inline
  typename vector< Type, Allocator >::reference
    vector< Type, Allocator >::operator[]( size_type n )
  {
    return( buffer[n] );
  }

  // operator[]( size_type ) const
  // *****************************
  template< class Type, class Allocator >
  inline typename vector< Type, Allocator >::const_reference
    vector< Type, Allocator >::operator[]( size_type n ) const
  {
    return( buffer[n] );
  }

  // at( size_type )
  // ***************
  template< class Type, class Allocator >
  typename vector< Type, Allocator >::reference
    vector< Type, Allocator >::at( size_type n )
  {
    if( n >= filled )
      throw out_of_range( "vector::at" );
    return( buffer[n] );
  }

  // at( size_type ) const
  // *********************
  template< class Type, class Allocator >
  typename vector< Type, Allocator >::const_reference
    vector< Type, Allocator >::at( size_type n ) const
  {
    if( n >= filled )
      throw out_of_range( "vector::at" );
    return( buffer[n] );
  }

  // front( )
  // ********
  template< class Type, class Allocator >
  inline
  typename vector< Type, Allocator >::reference
    vector< Type, Allocator >::front( )
  {
    return( buffer[0] );
  }

  // front( ) const
  // **************
  template< class Type, class Allocator >
  inline
  typename vector< Type, Allocator >::const_reference
    vector< Type, Allocator >::front( ) const
  {
    return( buffer[0] );
  }

  // back( )
  // *******
  template< class Type, class Allocator >
  inline
  typename vector< Type, Allocator >::reference
    vector< Type, Allocator >::back( )
  {
    return( buffer[filled - 1] );
  }

  // back( ) const
  // *************
  template< class Type, class Allocator >
  inline
  typename vector< Type, Allocator >::const_reference
    vector< Type, Allocator >::back( ) const
  {
    return( buffer[filled - 1] );
  }

  // push_back( const Type & )
  // *************************
  template< class Type, class Allocator >
  void vector< Type, Allocator >::push_back( const Type &item )
  {
    if( filled + 1 > total ) {
      reallocate( );
    }
    new ( static_cast<void *>( buffer + filled ) ) Type( item );
    ++filled;
  }

  // pop_back( )
  // ***********
  template< class Type, class Allocator >
  inline void vector< Type, Allocator >::pop_back( )
  {
    mem.destroy( &buffer[filled - 1] );
    --filled;
  }

  // reallocate( )
  // *************
  template< class Type, class Allocator >
  void vector< Type, Allocator >::reallocate( )
  {
    size_type temp_total = ( total << 1 );  // Check for overflow?
    pointer temp = mem.allocate( temp_total );
    try {
      uninitialized_copy( iterator( buffer ),
                          iterator( buffer + filled ),
                          iterator( temp ) );
    }
    catch( ... ) {
      mem.deallocate( temp, temp_total );
      throw;
    }

    // New allocation successful. Remove old vector and commit to new.
    pointer start = buffer;
    while( buffer < start + filled ) {
      buffer->~Type( );
      ++buffer;
    }
    total  = temp_total;
    buffer = temp;
  }

  // ===============================
  // Ordinary functions using vector
  // ===============================

  // operator==( const vector &, const vector & )
  // ++++++++++++++++++++++++++++++++++++++++++++
  template< class Type, class Allocator >
  bool operator==(
    const vector< Type, Allocator > &x,
    const vector< Type, Allocator > &y );

  // operator!=( const vector &, const vector & )
  // ++++++++++++++++++++++++++++++++++++++++++++
  template< class Type, class Allocator >
  inline
  bool operator!=(
    const vector< Type, Allocator > &x,
    const vector< Type, Allocator > &y )
  {
    return( !(x == y) );
  }

  // operator<( const vector &, const vector & )
  // +++++++++++++++++++++++++++++++++++++++++++
  template< class Type, class Allocator >
  bool operator<(
    const vector< Type, Allocator > &x,
    const vector< Type, Allocator > &y );

  // operator<=( const vector &, const vector & )
  // ++++++++++++++++++++++++++++++++++++++++++++
  template< class Type, class Allocator >
  inline
  bool operator<=(
    const vector< Type, Allocator > &x,
    const vector< Type, Allocator > &y )
  {
    return( !( x > y) );
  }

  // operator>( const vector &, const vector & )
  // +++++++++++++++++++++++++++++++++++++++++++
  template< class Type, class Allocator >
  inline
  bool operator>(
    const vector< Type, Allocator > &x,
    const vector< Type, Allocator > &y )
  {
    return( y < x);
  }

  // operator>=( const vector &, const vector & )
  // ++++++++++++++++++++++++++++++++++++++++++++
  template< class Type, class Allocator >
  inline
  bool operator>=(
    const vector< Type, Allocator > &x,
    const vector< Type, Allocator > &y )
  {
    return( !(x < y) );
  }

  // swap( vector &, vector & )
  // ++++++++++++++++++++++++++
  template< class Type, class Allocator >
  void swap( vector< Type, Allocator > &x, vector< Type, Allocator > &y );

} // End of namespace std.

#endif
