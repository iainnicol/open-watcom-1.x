///////////////////////////////////////////////////////////////////////////
// FILE: _rbtree (std::_OW::RedBlackTree definition)
//
:keep CPP_HDR
:include crwat.sp
//
// Description: This header is an OpenWatcom red black tree container 
//              implementation.
//              Although it not part of the 14882 C++ standard library it is 
//              written with a similar interface.
//              It is used by the OpenWatcom implementation of the C++
//              standard library (map, set, multimap, multiset)
///////////////////////////////////////////////////////////////////////////
#ifndef __RBTREE_H_INCLUDED
#define __RBTREE_H_INCLUDED
:include readonly.sp

#ifndef __cplusplus
#error The header _rbtree.h requires C++
#endif

#ifndef _UTILITY_INCLUDED
    #include <utility>
#endif
#ifndef _ITERATOR_INCLUDED
    #include <iterator>
#endif
#ifdef _FUNCTION_INCLUDED
    #include <function>
#endif
#ifdef _MEMORY_INCLUDED
    #include <memory>
#endif

namespace std{
namespace _ow{
    
/* ==================================================================
 * value wrappers
 * Two classes/functors for set and map that allow single keys and 
 * pairs to be used so memory is not wasted.  Provides a common 
 * interface for getting the key value so the same tree code can be used.
 */
template< class Key >
struct TreeKeyWrapper{
    typedef Key const value_type;
    Key const& operator()(value_type const & v) const {return v;}
    //static Key const& getKey(value_type const & v){return v;}
};
template< class Key, class Type >
struct TreePairWrapper{
    typedef pair< Key const, Type > value_type;
    Key const& operator()(value_type const & v) const {return v.first;}
    //static Key const& getKey(value_type const & v){return v.first;}
};

/* ==================================================================
 * Red-Black Tree container interface
 * To do: 
 *  * find out what supposed to do with allocator alloc/construct exceptions
 *  * rebind and copy allocator
 *  * finish off all functions so has 14882 style interface
 *  * finish off iterator ( const, operator->, ...)
 *  * check const is used where ever it can/needed
 */
template< class Key, class Type, class Compare = less< Key >,
          class Allocator = allocator< TreePairWrapper< Key, Type >::value_type >,
          class ValueWrapper = TreePairWrapper< Key, Type > >
class RedBlackTree{
public:
    typedef ValueWrapper::value_type value_type;
    typedef unsigned int size_type;

protected:
    struct Node{
        value_type value;
        Node* parent;
        Node* left;
        Node* right;
        enum chroma{red,black} colour;
        Node(const value_type& v, Node* const p = 0, chroma c = red) : 
            value(v), parent(p), left(0), right(0), colour(c){} 
    };

public:
    //ctors and dtor
    RedBlackTree() : mRoot(0), mFirst(0), mLast(0), mSize(0), mError(0){}
    RedBlackTree( RedBlackTree const & );
    RedBlackTree& operator=( RedBlackTree const & );
    ~RedBlackTree();

    /* ------------------------------------------------------------------
     * iterators
     */
    class iterator_base : public std::iterator< std::bidirectional_iterator_tag,
                                           value_type>{
        friend class RedBlackTree;
        typedef RedBlackTree<Key, Type, Compare, Allocator, ValueWrapper> rbt_type;
    public:
        bool operator==( iterator_base i ) {return( self==i.self );}
        bool operator!=( iterator_base i ) {return( self!=i.self );}
        iterator_base& operator++() {self = rbt->walkRight( self ); return *this;}
        iterator_base& operator--() {self ? self = rbt->walkLeft( self ) : self = rbt->mLast; return *this;}
    protected:
        iterator_base( iterator_base const & i ) : self(i.self), rbt(i.rbt) {}
        iterator_base() : self(0),rbt(0) {}
        iterator_base(rbt_type const * rb, Node* n) : self(n), rbt(rb) {}
        Node* getNodePtr() {return self;}
        Node* self;
        rbt_type const * rbt;
    };
    class const_iterator;
    class iterator : public iterator_base{
        friend class const_iterator;
    public:
        iterator( iterator const & i ) : iterator_base( i ) {}
        iterator() : iterator_base() {}
        iterator( rbt_type const * rb, Node* n ) : iterator_base( rb, n ) {}
        RedBlackTree::value_type& operator*() {return self->value;}
        RedBlackTree::value_type* operator->() {return &(self->value);}
        iterator& operator++() {return( (iterator&)iterator_base::operator++( ) );}
        iterator operator++( int ) {iterator i = *this; self = rbt->walkRight(self); return i;}
        iterator& operator--() {return( (iterator&)iterator_base::operator--( ) );} 
        iterator operator--(int) {iterator i = *this; self ? self = rbt->walkLeft(self) : self=rbt->mLast; return i;}
    };
    
    class const_iterator : public iterator_base{
    public:
        const_iterator( iterator const & i ) : iterator_base( i.rbt, i.self ) {}
        const_iterator() : iterator_base(){}
        const_iterator( rbt_type const* rb, Node* n ) : iterator_base( rb, n ) {}
        RedBlackTree::value_type const& operator*() {return self->value;}
        RedBlackTree::value_type const* operator->() {return &(self->value);}
        const_iterator& operator++() {return( (const_iterator&)iterator_base::operator++());}
        const_iterator operator++( int ) {const_iterator i = *this; self = rbt->walkRight(self); return i;}
        const_iterator& operator--() {return( (const_iterator&)iterator_base::operator--());} 
        const_iterator operator--(int) {const_iterator i = *this; self ? self = rbt->walkLeft(self) : self=rbt->mLast; return i;}
    };
    friend class iterator_base;
    friend class iterator;
    friend class const_iterator;
    /*
     * end of iterators
     * ------------------------------------------------------------------ */
    
    iterator end() {return iterator( this, (Node*) 0 );}
    iterator begin() {return iterator( this, mFirst );}
    const_iterator end() const {return const_iterator( this, (Node*) 0 );}
    const_iterator begin() const {return const_iterator( this, mFirst );}
    
    // pair< iterator, bool > insert( value_type const & );
    void erase( iterator );
    size_type erase( Key const & );
    //void erase(iterator first, iterator last);
    void clear();
    iterator find( Key const & );
    bool empty() const {return mSize==0;}
    size_type size() const {return mSize;}
    size_type max_size() const;

    bool _Sane();
    int mError;

protected:
    void doubleBlackTransform(Node* parent, bool lefty);
    void insBalTransform(Node* inserted);
    // std::pair<iterator,bool> unbalancedInsert(value_type const &);
    int blackHeight( iterator );
    int height( iterator );
    Node* walkRight( Node* ) const;
    Node* walkLeft( Node* ) const;
    int mSize;
    Node* mRoot;
    Node* mFirst;
    Node* mLast;
    Compare cmp;
    ValueWrapper keyGetter;
    std::allocator< Node > mem;             // !! Warning this is a deliberate mistake !!
    //Allocator::rebind< Node >::other mem; // to do: copy the rebound allocator
                                            // object here when compiler updated

// ---=== !!MOVE ME OUTTA HERE!! ===---
/* ------------------------------------------------------------------
 * unbalancedInsert( value_type const & )
 * like find but create new node after last node visited if cant find an existing key
 */
//template<class Key, class Type, class Compare, class Allocator, class Allocator, class ValueWrapper>
std::pair< RedBlackTree< Key, Type, Compare, Allocator, ValueWrapper >::iterator, bool >
RedBlackTree< Key, Type, Compare, Allocator, ValueWrapper >::unbalancedInsert(value_type const & v)
{
    if( mRoot==0 ){                 //special case nothing exists yet
        mRoot = mem.allocate( 1 );
        mem.construct( mRoot, Node(v, 0, Node::black) );       // ? to do catch exceptions?
        mFirst = mRoot;
        mLast = mRoot;
        mSize++;
        return std::pair<iterator, bool>(iterator(this, mRoot),true);
    }
    
    Node* n = mRoot;
    Node* notLT = 0;
    Node* last = mRoot;
    bool LtLast;
    
    while( n ){
        if( cmp(keyGetter(v), keyGetter(n->value) ) ){
            last = n;
            LtLast = true;
            n = n->left;
        }
        else{
            last = n;
            LtLast = false;
            notLT = n;
            n = n->right;
        }
    }
    // the last node the key is not less than (if any) may be equal,
    // in which case it was found 
    if( notLT && 
        !( cmp(keyGetter(notLT->value), keyGetter(v) ) ) ){
            // !(a<b) & !(b<a) then a==b
            return std::pair<iterator,bool>(iterator(this, notLT), false);
    }
    // else insert the new node with parent as last node travelled to
    Node* newnode = mem.allocate( 1 );
    mem.construct( newnode, Node(v, last, Node::red) );   // ?to do catch exceptions?
    
    mSize++;
    if( LtLast ){
        last->left = newnode;
        if(last == mFirst) mFirst = newnode;
    }else{
        last->right = newnode;
        if(last == mLast) mLast = newnode;
    }
    
    return std::pair<iterator,bool>(iterator(this, newnode), true);
}

public:
/* ------------------------------------------------------------------
 * insert  !!MOVE ME OUTSIDE CLASS!!
 * supports ... operations
 */
//template<class Key, class Type, class Compare, class Allocator, class Allocator, class ValueWrapper>
std::pair< RedBlackTree< Key, Type, Compare, Allocator, ValueWrapper >::iterator, bool >
RedBlackTree< Key, Type, Compare, Allocator, ValueWrapper >::insert(value_type const & v)
{
    pair< iterator, bool > inserted = unbalancedInsert(v);
    if( inserted.second ){ 
        Node* n = inserted.first.getNodePtr();
        if( n!=mRoot ) {
            //do some operations to keep rb tree valid
            insBalTransform(n);
        }//else if n==mRoot it has been inserted as single black node
         //and there is nothing else to do
    }
    return inserted;
}

};//class RedBlackTree


/* ==================================================================
 * Red-Black Tree Functions
 */
/* ------------------------------------------------------------------
 * Copy Ctor
 */
template< class Key, class Type, class Compare, class Allocator, class ValueWrapper >
RedBlackTree< Key, Type, Compare, Allocator, ValueWrapper >::RedBlackTree(
    RedBlackTree< Key, Type, Compare, Allocator, ValueWrapper > const & that)
{
    //copy allocator ?
    //copy comparator ? 
    //other bits?
    mSize = that.mSize;
    //copy nodes
    //special case node
    if( !that.mRoot ){  // no root, therefore first and last don't exist either
        mFirst = 0;
        mLast = 0;
        mRoot = 0;
        //cout<<"no root\n";
        return;
    }
    mRoot = mem.allocate( 1 );
    mem.construct( mRoot, Node(that.mRoot->value,0,that.mRoot->colour) );
    
    Node* n;
    Node* o;
    
    o = that.mRoot;
    n = mRoot;
    for(;;){
        //check to see if reached first/last and fix up
        if( o == that.mFirst ){
            mFirst = n;
        }
        if( o == that.mLast ){
            mLast = n;
        }
        //logic for tree traverse and copy
        if( o->left && !n->left ){
            //copy left node if we can/haven't already
            o = o->left;
            n->left = mem.allocate( 1 );
            mem.construct( n->left, Node( o->value, n, o->colour ) );
            n = n->left;
        }else if( o->right && !n->right ){
            //or copy right node if we can/haven't already
            o = o->right;
            n->right = mem.allocate( 1 );
            mem.construct( n->right, Node( o->value, n, o->colour ) );
            n = n->right;
        }else if( o->parent ){
            //no children nodes left to copy, move back up
            o = o->parent;
            n = n->parent;
        }else{
            //no children nodes left to copy and we are root
            //therefore finished
            return;
        }
    }//end for( ;; )
}
/* ------------------------------------------------------------------
 * operator=
 */
template< class Key, class Type, class Compare, class Allocator, class ValueWrapper >
RedBlackTree< Key, Type, Compare, Allocator, ValueWrapper >&
RedBlackTree< Key, Type, Compare, Allocator, ValueWrapper >::operator=(
    RedBlackTree< Key, Type, Compare, Allocator, ValueWrapper > const & that )
{
    //cout<<"rbt operator=\n";
    clear();
    new ( this ) RedBlackTree( that );  //call copy ctor to do the copy
    return( *this );
}
/* ------------------------------------------------------------------
 * Dtor
 */
template< class Key, class Type, class Compare, class Allocator, class ValueWrapper >
RedBlackTree< Key, Type, Compare, Allocator, ValueWrapper >::~RedBlackTree()
{
    clear();
}
/* ------------------------------------------------------------------
 * clear()
 * erase all elements. Should be quicker than iterating through each
 * one as we don't have to walk and rebalance
 */
template< class Key, class Type, class Compare, class Allocator, class ValueWrapper >
void RedBlackTree< Key, Type, Compare, Allocator, ValueWrapper >::clear( )
{
    Node* n = mFirst;
    while( n ){
        if( n->left ) n = n->left;
        else if( n->right ) n = n->right;
        else{
            //delete it when all children gone
            if( !n->parent ){ 
                //if no parent then root, therefore finished
                mem.destroy( n );
                mem.deallocate( n, 1 );
                mSize = 0;
                mRoot = 0;
                mFirst = 0;
                mLast = 0;
                return; 
            }
            if( n == n->parent->left ) n->parent->left = 0;
            else n->parent->right = 0;
            Node* delme = n;
            n = n->parent;
            mem.destroy( delme );
            mem.deallocate( delme, 1 );
        }
    }
}
/* ------------------------------------------------------------------
 * Find( )
 * Climb the tree until we get to the key :)
 */
template< class Key, class Type, class Compare, class Allocator, class ValueWrapper >
RedBlackTree< Key, Type, Compare, Allocator, ValueWrapper >::iterator 
RedBlackTree< Key, Type, Compare, Allocator, ValueWrapper >::find(Key const& findMe)
{
    Node* n=mRoot;
    Node* notLT=0;
    
    while( n ){
        if( cmp(findMe, keyGetter(n->value) ) ) n=n->left;
        else{
            notLT=n;
            n=n->right;
        }
    }
    // the last node the key is not less than (if any) may be equal, in which case it was found 
    if( notLT && !(cmp(keyGetter(notLT->value), findMe) ) )    // !(a<b) & !(b<a) then a==b
        return iterator(this, notLT);
    else
        return end();
}
/* ------------------------------------------------------------------
 * walkRight( Node* )
 * iterate to next greater node 
 */
template< class Key, class Type, class Compare, class Allocator, class ValueWrapper >
RedBlackTree< Key, Type, Compare, Allocator, ValueWrapper >::Node*
RedBlackTree< Key, Type, Compare, Allocator, ValueWrapper >::walkRight(Node* n) const
{
    if( n->right){
        n = n->right;
        while(n->left) n = n->left;
    }else{
        while(n->parent && (n == n->parent->right) ) n = n->parent;
        n = n->parent;
    }
    return n;
}
/* ------------------------------------------------------------------
 * walkLeft( Node* )
 * iterate to next node with lower key
 */
template< class Key, class Type, class Compare, class Allocator, class ValueWrapper >
RedBlackTree< Key, Type, Compare, Allocator, ValueWrapper >::Node*
RedBlackTree< Key, Type, Compare, Allocator, ValueWrapper >::walkLeft(Node* n) const
{
    if( n->left){
        n = n->left;
        while(n->right) n = n->right;
    }else{
        while(n->parent && (n == n->parent->left) ) n = n->parent;
        n = n->parent;
    }
    return n;
}
/* ------------------------------------------------------------------
 * blackHeight( iterator )
 * calculate black height of node
 */
template< class Key, class Type, class Compare, class Allocator, class ValueWrapper >
int RedBlackTree< Key, Type, Compare, Allocator, ValueWrapper >::blackHeight(iterator i)
{
    Node* n = i.getNodePtr();
    int c = 0;
    while(n){
        if( n->colour==Node::black ) c++;
        n = n->parent;
    }
    return c;
}
/* ------------------------------------------------------------------
 * height( iterator )
 * calculate height of node
 */
template< class Key, class Type, class Compare, class Allocator, class ValueWrapper >
int RedBlackTree< Key, Type, Compare, Allocator, ValueWrapper >::height(iterator i)
{
    Node* n = i.getNodePtr();
    int c = 0;
    while(n){
        c++;
        n = n->parent;
    }
    return c;
}
/* ------------------------------------------------------------------
 * insBalTransform
 * Ref: Chris Okasaki paper (2005?) proposing simple transform for insert ballance
 * and Lyn Turbak CS231 handout #21 (2001)
 * 
 * if uncle is red we just do a colour change, if uncle is black we do a transform
 * in summary 4 cases transform to this:
 *        y(b)          
 *      /     \         
 *    x(r)    z(r)      
 *  /   \     /   \     
 * a(b) b(b) c(b) d(b)  
 *
 * case 1:          case 2:        case 3:         case 4:
 * (insert x)      (insert y)     (insert z)      (insert y)
 *       z             z             x                x
 *      / \           / \           / \              / \
 *     y   d         x   d         a   y            a   z
 *    / \           / \               / \              / \
 *   x   c         a   y             b   z            y   d
 *  / \               / \               / \          / \
 * a   b             b   c             c   d        b   c
 */
template<class Key, class Type, class Compare, class Allocator, class ValueWrapper>
void RedBlackTree<Key, Type, Compare, Allocator, ValueWrapper>::insBalTransform(Node* inserted)
{
    // at this point inserted->colour == red;
    for( ;; ){ 
    /* terminating case
     * 1. we have moved up the tree and are now the root
     * 2. our parent is the root (therefore must be black)
     * 3. our parent is black (no red-red problem any more)
     */
        if( inserted->parent == 0 ||
            inserted->parent->parent == 0 ||
            inserted->parent->colour == Node::black )
            return;

    /* so at this point parent must also be red, and grandparent must be black
     * therefore our sibling must be black (our children are black by definition)
     * leaving two main cases : our uncle can black or red
     */
        Node* parent = inserted->parent;
        Node* grandparent = inserted->parent->parent;
        Node* uncle;
        //find uncle
        if( parent == grandparent->left ) uncle = grandparent->right;
        else uncle = grandparent->left;

        if( uncle && (uncle->colour == Node::red) ){    // main case a: red uncle
            // now we propergate grandparents blackness between parent and uncle
            // (without need to rotate)
            grandparent->colour = Node::red;
            parent->colour = Node::black;
            uncle->colour = Node::black;
            mRoot->colour = Node::black;    //just in case grandparent was root
            inserted = grandparent;         //prepare to propergate red-red up tree
            //the execusion flow now jumps back to the for loop instead
            //of recursive insBalTransform( inserted );
        }else{ //main case b:  black uncle
            Node *x,*y,*z,*b,*c;
            //case 1
            if( (inserted == parent->left) && (parent == grandparent->left) ){
                x = inserted;
                y = parent;
                z = grandparent;
                b = x->right;
                c = y->right;
            }
            //case 2 
            else if( (inserted == parent->right) && (parent == grandparent->left) ){
                x = parent;
                y = inserted;
                z = grandparent;
                b = y->left;
                c = y->right;
            }
            //case 3
            else if( (inserted == parent->right) && (parent == grandparent->right) ){
                x = grandparent;
                y = parent;
                z = inserted;
                b = y->left;
                c = z->left;
            }
            //case4
            else if( (inserted == parent->left) && (parent == grandparent->right) ){
                x = grandparent;
                y = inserted;
                z = parent;
                b = y->left;
                c = y->right;
            }
            
            //recolour - can use this order becase all leafs a,b,c,d must
            //be black (uncle is black)
            //this will stop red-red violation from propergating
            y->colour = Node::black;
            x->colour = Node::red;
            z->colour = Node::red;
            
            //transform to balanced structure
            if( grandparent==mRoot ){
                mRoot = y;
                y->parent = 0;
            }else{
                if (grandparent->parent->left == grandparent){
                    grandparent->parent->left = y;
                }else{ //grandparent is righty
                    grandparent->parent->right = y;
                }
                y->parent = grandparent->parent;
            }
            
            y->left = x;
            y->right = z;
            x->parent = y;
            z->parent = y;
            x->right = b;
            z->left = c;
            if(b) b->parent = x;
            if(c) c->parent = z;
            //a and d are always already linked to the right parent
            //in this case we have fixed the red-red violation so finish
            return;
        }//end main case uncle black
    }//end for( ever )
}
/* ------------------------------------------------------------------
 * _Sane( )
 * test the implementation for errors and
 * test the container hasn't been corrupt
 * return true if everything is ok
 */
template< class Key, class Type, class Compare, class Allocator, class ValueWrapper >
bool RedBlackTree< Key, Type, Compare, Allocator, ValueWrapper >::_Sane()
{
    if( !mRoot ){
        //no element in tree
        if( mSize != 0 ){
            mError = 10;
            return false;
        }else{
            //nothing else in tree to check
            return true;
        }
    }
    iterator it = begin();
    Node* n = it.getNodePtr();
    Node* highN = n;
    Node* lowN = n;
    Key const * lowkey = &keyGetter(n->value);
    Key const * highkey = &keyGetter(n->value);
    int count = 0;
    int maxheight = height(it);
    int bheight = -1;
    
    if( n->left ){              //begining element cant have a left node
        mError = 20;
        return false;
    }
    if( mRoot->colour != Node::black ){
        mError = 25;
        return false;           //root should always be black
    }
    
    do{
        if( ++count > size() ){
            mError = 30;                // we could have got trapped in
            return false;               // a loop, cant be more iterations
        }                               // than size
        value_type v_old = n->value;
        n = it.getNodePtr();
        if( (it != begin()) && (v_old == n->value) ){
            mError = 40;                //circular links:
            return false;               //iterating didn't advance
        }
        if( (n->colour == Node::red) &&
            (n->parent) &&
            (n->parent->colour == Node::red) ){
            mError = 50;
            return false;               //red-red error
        }
        if( (n->parent) &&
            (n->parent->left != n) &&
            (n->parent->right != n) ){
            mError = 60;
            return false;               //links broken
        }
        if( (!n->parent) && (mRoot !=n) ){
            mError = 70;
            return false;              //links broken
        }
        if( (n->left == n) || (n->right == n) ){
            mError = 80;
            return false;               //simple circular loop detection
            //? not sure this works as iterating will get stuck before
            //detection ?
        }
        if( !n->parent && n!=mRoot){
            mError = 90;
            return false;               //no parent but not root
        }
        //keep track of the lowest key we come across
        if( cmp( keyGetter(n->value), *lowkey) ){
            lowkey = &keyGetter(n->value);
            lowN = n;
        }
        //keep track of the highest key we come across
        if( cmp(*highkey, keyGetter(n->value)) ){
            highkey = &keyGetter(n->value);
            highN = n;
        }
        if( !n->left || !n->right ){    //null child is a leaf
            int bh = blackHeight(it);
            if( bheight == -1 ) bheight = bh;
            else if(bheight != bh){
                mError = 100;
                return false;           //black height to leaves not same
            }
        }
        int h = height(it);             //keep track of deepest node depth
        if( h > maxheight ) maxheight = h;
        
    }while( ++it != end() );
    
    if( count != size() ){
        mError = 110;
        return false;
    }        
    if( n->right ){ // end element cant have a right node
        mError = 120;
        return false;
    }
    if( (highN != (--end()).getNodePtr()) ||
        (lowN != begin().getNodePtr()) ){
        mError = 130;
        return false;
    }
    return true;
}
/* ------------------------------------------------------------------
 * Erase( key )
 */
template< class Key, class Type, class Compare, class Allocator, class ValueWrapper >
RedBlackTree< Key, Type, Compare, Allocator, ValueWrapper >::size_type
RedBlackTree< Key, Type, Compare, Allocator, ValueWrapper >::erase(const Key& k)
{
    iterator it = find(k);
    if(it == end()) return 0;
    else{
        erase(it);
        return 1;
    }
}
/* ------------------------------------------------------------------
 * Erase( iterator )
 * Maybe to do: this isn't the most easy to understand, is there a nicer
 * way of writing it?
 */
template< class Key, class Type, class Compare, class Allocator, class ValueWrapper >
void RedBlackTree< Key, Type, Compare, Allocator, ValueWrapper >::erase(iterator it)
{
    Node* delme = it.getNodePtr();
    Node* child;    //(re)moved endnode child
    Node* parent;   // parent of (re)moved endnode 
    bool lefty;     //true if (re)moved endnode was left child
    Node::chroma colour;    //(re)moved endnode colour
    
    mSize--;
    
    if( delme == mFirst ){
        if( delme == mLast ){
            //special case, deleted == only element in tree
            mFirst = 0;
            mLast = 0;
        }else 
            mFirst = walkRight(delme);
    }else if( delme == mLast) mLast = walkLeft(delme);
    
    //if not end node swap for predecessor
    if( delme->left && delme->right){
        Node* predecessor = walkLeft(delme);
        colour = predecessor->colour;
        child = predecessor->left;  //predecessor can't have a right child
        if( predecessor == predecessor->parent->left ) lefty = true;
        else lefty = false;
        //fix up parent's link 
        if( delme == mRoot )
            mRoot = predecessor;
        else if( delme == delme->parent->left ){
            delme->parent->left = predecessor;
        }else{
            delme->parent->right = predecessor;
        }
        //if delme is one level above predecessor we have to be
        //careful linking left as it could create a circular link
        //and a link to the deleted item
        if(predecessor != delme->left){
            //fix up chidren's link
            delme->left->parent = predecessor;
            //fix predecessors link
            predecessor->left = delme->left;
            parent = predecessor->parent;
        }else{ //predecessor is erased node's child
            parent = predecessor;
            //leave old left child links intact
        }
        //common bits
        //fix childrens links
        delme->right->parent = predecessor;
        //fix predecessor's links
        predecessor->colour = delme->colour;
        predecessor->parent = delme->parent;
        predecessor->right = delme->right;
    }
    else{ //end node
        if( delme->left ) child = delme->left;
        else child = delme->right;
        parent = delme->parent;
        colour = delme->colour;
        if( parent && (delme == parent->left) ) lefty = true;
        else lefty = false;
    }
    
    //delete delme;
    mem.destroy( delme );
    mem.deallocate( delme, 1 );
    //handle simple cases
    if( !parent ){
        //root with up to 1 child
        if( child ){
            mRoot = child;
            mRoot->parent = 0;
            mRoot->colour = Node::black;
        }else{
            mRoot = 0;
        }
    }else if( colour == Node::red ){
        //red end node cant have a single child node or it would have
        //violated red-red rule or black height rule
        //removing it doesn't change black height so we are done
        if( lefty ) parent->left = 0;
        else parent->right = 0;
    }else if( child ){
        //black end node may have a single child, in which case
        //it has to be red and we can fix up the black height easily
        if( lefty ){
            parent->left = child;
            child->parent = parent;
        }else{ //righty
            parent->right = child;
            child->parent = parent;
        }
        child->colour = Node::black;
    }else{
        //black node with no children, 
        if( lefty ) parent->left = 0;
        else parent->right = 0;
        //(re)moving this will cause black height problem
        //do some operations to keep rb tree valid
        doubleBlackTransform(parent,lefty);
    }
    
    return;
}
/* ------------------------------------------------------------------
 * DoubleBlackTransform
 * Fix double-black node to rebalance the tree after delete
 * 
 * references:
 * backs of lots of matchboxes :)
 *
 * (this doesn't touch key or type, can the compiler figure out it
 *  can use one block of code for all template instantiations or does
 *  it need to be coded in a non template base class?)
 */
template< class Key, class Type, class Compare, class Allocator, class ValueWrapper >
void RedBlackTree< Key, Type, Compare, Allocator, ValueWrapper >::doubleBlackTransform(Node* parent, bool lefty)
{
    for( ;; ){
        Node* sibling;
        Node *x,*y,*z,*b,*c;
        if( lefty ){
            sibling = parent->right;
        }else{ //righty
            sibling = parent->left;
        }
        
        if( sibling->colour == Node::black ){
            if( ( sibling->right && (sibling->right->colour == Node::red) ) ||
                ( sibling->left && (sibling->left->colour == Node::red) ) ){
        //main case 1 sibling black, at least one nephew red
        //we can fix this case
        /*
         *     case a               case b        case c              case d    
         *      Z(*)                 Z(*)          X(*)                X(*)     
         *     /   \\               /   \\       //    \             //    \    
         *   X(b)   d(bb)         Y(b)   d(bb)  a(bb)   Y(b)       a(bb)   Z(b) 
         *  /    \               /    \                 /  \              /  \  
         * a(*)   Y(r)          X(r)  c(*)            b(*) Z(r)         Y(r) d(*)
         *       /   \         /   \                       /   \       /   \    
         *     b(b)   c(b)   a(b)  b(b)                   c(b) d(b)   b(b) c(b) 
         *
         * Transform to this:
         *       Y(*)
         *      /     \
         *   X(b)      Z(b)
         *  /   \     /   \
         * a(*) b(*) c(*) d(*)
         *
         * where double black goes black & new root takes old root colour
         * note nodes a,b,c may be null (leafs)
         */
                if( sibling->right && (sibling->right->colour == Node::red) ){
                    if( lefty ){        // case 1 c
                        x = parent;
                        y = sibling;
                        z = sibling->right;
                        b = y->left;
                        c = z->left;
                    }else{              // case 1 a
                        z = parent;
                        x = sibling;
                        y = sibling->right;
                        b = y->left;
                        c = y->right;
                    }
                }else{ // sibling->left && sibling->left->colour == red 
                    if( lefty ){        // case 1 d
                        x = parent;
                        z = sibling;
                        y = sibling->left;
                        b = y->left;
                        c = y->right;
                    }else{              // case 1 b
                        z = parent;
                        y = sibling;
                        x = sibling->left;
                        b = x->right;
                        c = y->right;
                    }
                }
                // finish off case 1 by relinking to correct sturcture
                y->parent = parent->parent;
                if( parent == mRoot ) mRoot = y;
                else{    //link grandparent back to y;
                    if( parent == parent->parent->left ) 
                        parent->parent->left = y;
                    else parent->parent->right = y;
                }
                y->colour = parent->colour;
                y->left = x;
                y->right = z;
                x->parent = y;
                x->colour = Node::black;
                x->right = b;       // x->left is unchanged as a
                if( b ) b->parent = x;
                z->parent = y;
                z->colour = Node::black;
                z->left = c;        // z->right is unchanged as d
                if( c ) c->parent = z;
                return;
            }else{  //nephews both black
                if( parent->colour == Node::red){
        //main case 2: sibling black, two black nephews, parent red
        //we can fix this case
        /*
         *      case a           case b         
         *       Z(r)             X(r)          
         *      /   \\           //   \         
         *    X(b)   d(bb)     a(bb)  Z(b)      
         *   /    \                  /    \     
         *  a(b)   b(b)             b(b)  d(b)  
         * 
         * Recolour to this:
         *        Z(b)              X(b)        
         *       /    \            /    \       
         *    X(r)    d(b)       a(b)   Z(r)    
         *   /   \                     /    \   
         *  a(b) b(b)                b(b)   d(b)
         *
         */
                    parent->colour = Node::black;
                    sibling->colour = Node::red;
                    return;
                }else{ //parent black
        //main case 3: sibling black, two black nephews, parent black
        /*
         *        case a           case b       
         *         Z(b)             X(b)        
         *        /   \\           //   \       
         *      X(b)   d(bb)     a(bb)  Z(b)    
         *     /    \                  /    \   
         *    a(b)   b(b)             b(b)  d(b)
         * 
         * Recolour to propergate double black:
         *        ||                ||          
         *       Z(bb)             X(bb)        
         *      /     \           /    \        
         *   X(r)      d(b)     a(b)   Z(r)     
         *  /   \                     /    \    
         * a(b) b(b)                b(b)   d(b) 
         *
         * Not much we can do - propergate double black
         * If double black has properaged to to root just set it black 
         * as we have acheived balance
         * (higher order special cases may be possible eg node a has two 
         * red children but probably not worth the extra code to check?)
         */
                    sibling->colour = Node::red;
                    if( parent == mRoot ){
                        parent->colour = Node::black;
                        return;
                    }
                    Node* grandparent = parent->parent;
                    if( parent == grandparent->left) lefty = true;
                    else lefty = false;
                    //loop to top of doubleBlackTransform with new parent
                    //(replaces recursion)
                    //doubleBlackTransform(grandparent, lefty); return;
                    parent = grandparent;
                }
            } //end main case 2/3
        }else{
        //main case 4: red sibling
        /*
         *        case a           case b       
         *         Z(b)             X(b)        
         *        /   \\           //   \       
         *      X(r)   d(bb)     a(bb)  Z(r)    
         *     /    \                  /    \   
         *    a(b)   b(b)             c(b)  d(b)
         * 
         * Recolour to propergate double black:
         *       X(b)                   Z(b)    
         *      /    \                 /    \   
         *   a(b)     Z(r)           X(r)   d(b)
         *           /   \\         //  \       
         *         b(b)  d(bb)   a(bb)  c(b)    
         *
         * This is an annoying one!
         * Note, a and b must have children (ie a/b can't be null/leaves) or the 
         * black height doesn't add up.
         * Double black stays with the same node but restructure so we can 
         * use one of the previous cases (1 or 2) where the sibling is black.
         */
            //common bits
            if( parent == mRoot ){
                mRoot = sibling;
                sibling->parent = 0;
            }else if ( parent == parent->parent->left ){
                parent->parent->left = sibling;
                sibling->parent = parent->parent;
            }else{//parent is a righty
                parent->parent->right = sibling;
                sibling->parent = parent->parent;
            }
            parent->colour = Node::red;
            sibling->colour = Node::black;
            
            if( lefty ){
                //case b
                x = parent;
                c = sibling->left;
                z = sibling;
                x->right = c;      
                c->parent = x;
                x->parent = z;
                z->left = x;
                //a & d stay linked to the same nodes
            }else{  //righty
                //case a
                z = parent;
                b = sibling->right;
                x = sibling;
                z->left = b;
                b->parent = z;
                z->parent = x;
                x->right = z;
                //a & d stay linked to the same nodes
            }
            //now try again and case will be 1, 2, or 3
            //note old parent is still parent of double black
            //and left/right position of double black hasn't changed
            //recursion has been replaced with the for loop
            //doubleBlackTransform(parent,lefty); return;
        }
    }//end for( ever )
}

}; //namespace _ow
}; //namespace std

#endif
