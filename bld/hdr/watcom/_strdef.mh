///////////////////////////////////////////////////////////////////////////
// FILE: _strdef.h (Definition of std::string)
//
:keep CPP_HDR
:include crwat.sp
//
// Description: This is a helper header. It contains the definition of
//              std::string and enough other information so that the
//              standard exception classes can use strings. Yet this
//              header does not require the inclusion of the exception
//              headers and thus mutually recursive inclusions are
//              avoided.
///////////////////////////////////////////////////////////////////////////
#ifndef __STRDEF_H_INCLUDED
#define __STRDEF_H_INCLUDED

:include readonly.sp

#ifndef __cplusplus
#error The header _strdef.h requires C++
#endif

#if !defined(_STRING_INCLUDED) && !defined(_EXCEPTION_INCLUDED)
#error The header _strdef.h is not to be directly included in user programs
#endif

#include <cstring>
#include <cwchar>
#include <memory>

#define typename

namespace std {

  // struct char_traits
  // ******************
  template< class CharT > struct char_traits { };

  // struct char_traits< char >
  // **************************
  template< >
  struct char_traits< char > {
    typedef char      char_type;
    typedef int       int_type;
    typedef mbstate_t state_type;

    static void assign( char_type &c1, const char_type &c2 )
      { c1 = c2; }

    static bool eq( const char_type &c1, const char_type &c2 )
      { return( c1 == c2 ); }

    static bool lt( const char_type &c1, const char_type &c2 )
      { return( c1 < c2 ); }

    static int compare( const char_type *s1, const char_type *s2, size_t n )
      { return( memcmp(s1, s2, n ) ); }

    static size_t length( const char_type *s )
      { return( strlen(s) ); }

    static const char_type *find( const char_type *s, size_t n, const char_type &a )
      { return( static_cast< char_type * >( memchr(s, a, n) ) ); }

    static char_type *move( char_type *s1, const char_type *s2, size_t n )
      { return( static_cast< char_type * >( memmove(s1, s2, n) ) ); }

    static char_type *copy( char_type *s1, const char_type *s2, size_t n )
      { return( static_cast< char_type * >( memcpy(s1, s2, n) ) ); }

    static char_type *assign( char_type *s, size_t n, char_type a )
      { return( static_cast< char_type * >( memset(s, a, n) ) ); }

    static int_type not_eof( const int_type &c )
      { return( (c != EOF) ? c : 0 ); }

    static char_type to_char_type( const int_type &c )
      { return( static_cast< char_type >(c) ); }

    static int_type to_int_type( const char_type &c )
      { return( static_cast< int_type >(c) ); }

    static bool eq_int_type( const int_type &c1, const int_type &c2 )
      { return( c1 == c2 ); }

    static int_type eof( )
      { return( EOF ); }
  };

  // struct char_traits< wchar_t >
  // *****************************
  template< >
  struct char_traits< wchar_t > {
    typedef wchar_t   char_type;
    typedef wint_t    int_type;
    typedef mbstate_t state_type;

    static void assign( char_type &c1, const char_type &c2 )
      { c1 = c2; }

    static bool eq( const char_type &c1, const char_type &c2 )
      { return( c1 == c2 ); }

    static bool lt( const char_type &c1, const char_type &c2 )
      { return( c1 < c2 ); }

    static int compare( const char_type *s1, const char_type *s2, size_t n )
    {
      for( size_t i = 0; i < n; ++i ) {
        if( *s1 < *s2 ) return( -1 );
        if( *s1 > *s2 ) return(  1 );
        ++s1; ++s2;
      }
      return( 0 );
    }

    static size_t length( const char_type *s )
      { return( wcslen(s) ); }

    static const char_type *find( const char_type *s, size_t n, const char_type &a )
    {
      const char_type *result = 0;
      for( size_t i = 0; i < n; ++i ) {
        if( *s == a ) {
          result = s;
          break;
        }
        ++s;
      }
      return( result );
    }

    static char_type *move( char_type *s1, const char_type *s2, size_t n )
    {
      return( static_cast< char_type * >
              ( memmove(s1, s2, n * sizeof( char_type ) ) ) );
    }

    static char_type *copy( char_type *s1, const char_type *s2, size_t n )
    {
      return( static_cast< char_type * >
              ( memcpy(s1, s2, n * sizeof( char_type ) ) ) );
    }

    static char_type *assign( char_type *s, size_t n, char_type a )
    {
      char_type *p = s;
      for( size_t i = 0; i < n; ++i ) {
        *p = a;
        ++p;
      }
      return( s );
    }

    static int_type not_eof( const int_type &c )
      { return( (c != WEOF) ? c : static_cast< int_type >( 0 ) ); }

    static char_type to_char_type( const int_type &c )
      { return( static_cast< char_type >(c) ); }

    static int_type to_int_type( const char_type &c )
      { return( static_cast< int_type >(c) ); }

    static bool eq_int_type( const int_type &c1, const int_type &c2 )
      { return( c1 == c2 ); }

    static int_type eof( )
      { return( WEOF ); }
  };

} // namespace std


namespace std {

  // ===================================
  // Definition of basic_string template
  // ===================================

  template< class CharT,
            class Traits = char_traits< CharT >,
            class Allocator = allocator< CharT > >
  class basic_string {

    friend
    bool operator==( const basic_string< CharT, Traits, Allocator > &left,
                     const basic_string< CharT, Traits, Allocator > &right );
          
    friend
    bool operator==( const CharT *left,
                     const basic_string< CharT, Traits, Allocator > &right );

    friend
    bool operator==( const basic_string< CharT, Traits, Allocator > &left,
                     const CharT *right );

    friend
    bool operator<( const basic_string< CharT, Traits, Allocator > &left,
                    const basic_string< CharT, Traits, Allocator > &right );

    friend
    bool operator<( const CharT *left,
                    const basic_string< CharT, Traits, Allocator > &right );

    friend
    bool operator<( const basic_string< CharT, Traits, Allocator > &left,
                    const CharT *right );

    friend
    void swap( basic_string< CharT, Traits, Allocator > &left,
               basic_string< CharT, Traits, Allocator > &right );

    public:
      typedef          Traits                     traits_type;
      typedef typename Traits::char_type          value_type;
      typedef          Allocator                  allocator_type;
      typedef typename Allocator::size_type       size_type;
      typedef typename Allocator::difference_type difference_type;
      typedef typename Allocator::reference       reference;
      typedef typename Allocator::const_reference const_reference;
      typedef typename Allocator::pointer         pointer;
      typedef typename Allocator::const_pointer   const_pointer;

      typedef pointer iterator;
      typedef const_pointer const_iterator;

      static const size_type npos = static_cast< size_type >( -1 );

      // Constructors.
      explicit basic_string( const Allocator &a = Allocator( ) );
      basic_string( const basic_string &str );
      basic_string( const basic_string &str, size_type pos, size_type n = npos, const Allocator &a = Allocator( ) );
      basic_string( const CharT *s, size_type n, const Allocator &a = Allocator( ) );
      basic_string( const CharT *s, const Allocator &a = Allocator( ) );
      basic_string( size_type n, CharT c, const Allocator &a = Allocator( ) );

     ~basic_string( );

      basic_string &operator=( const basic_string &str );
      basic_string &operator=( const CharT *s );
      basic_string &operator=( CharT c );

      basic_string &assign( const basic_string &str, size_type pos = 0, size_type n = npos );
      basic_string &assign( const CharT *s, size_type n );
      basic_string &assign( const CharT *s );
      basic_string &assign( size_type n, CharT c );

      iterator       begin( );
      const_iterator begin( ) const;
      iterator       end( );
      const_iterator end( ) const;

      size_type size( ) const;
      size_type length( ) const;
      size_type capacity( ) const;
      size_type max_size( ) const;
      void      resize( size_type n, CharT c = CharT( ) );
      void      reserve( size_type new_capacity );
      void      clear( );
      bool      empty( ) const;

      const_reference operator[]( size_type pos ) const;
      reference       operator[]( size_type pos );
      const_reference at( size_type pos ) const;
      reference       at( size_type pos );

      basic_string &operator+=( const basic_string &str );
      basic_string &operator+=( const CharT *s );
      basic_string &operator+=( CharT c );

      basic_string &append( const basic_string &str, size_type pos = 0, size_type n = npos );
      basic_string &append( const CharT *s, size_type n );
      basic_string &append( const CharT *s );
      basic_string &append( size_type n, CharT c );

      void          push_back( CharT c );

      basic_string &insert( size_type pos1, const basic_string &str, size_type pos2 = 0, size_type n = npos );
      basic_string &insert( size_type pos, const CharT *s, size_type n );
      basic_string &insert( size_type pos, const CharT *s );
      basic_string &insert( size_type pos, size_type n, CharT c );
      iterator      insert( iterator p, CharT c );
      void          insert( iterator p, size_type n, CharT c );

      basic_string &erase( size_type pos = 0, size_type n = npos );
      iterator      erase( iterator p );
      iterator      erase( iterator first, iterator last );

      basic_string &replace( size_type pos1, size_type n, const basic_string &str );
      basic_string &replace( size_type pos1, size_type n1, const basic_string &str, size_type pos2, size_type n2 );
      basic_string &replace( size_type pos, size_type n1, const CharT *s, size_type n2 );
      basic_string &replace( size_type pos, size_type n1, const CharT *s );
      basic_string &replace( size_type pos, size_type n1, size_type n2, CharT c );
      basic_string &replace( iterator i1, iterator i2, const basic_string &str );
      basic_string &replace( iterator i1, iterator i2, const CharT *s, size_type n );
      basic_string &replace( iterator i1, iterator i2, const CharT *s );
      basic_string &replace( iterator i1, iterator i2, size_type n, CharT c );

      size_type     copy( CharT *s, size_type n, size_type pos = 0 ) const;
      void          swap( basic_string &str );

      const CharT   *c_str( ) const;
      const CharT   *data( ) const;
      allocator_type get_allocator( ) const;

      size_type find( const basic_string &str, size_type pos = 0 ) const;
      size_type find( const CharT *s, size_type pos, size_type n ) const;
      size_type find( const CharT *s, size_type pos = 0 ) const;
      size_type find( CharT c, size_type pos = 0 ) const;

      size_type rfind( const basic_string &str, size_type pos = npos ) const;
      size_type rfind( const CharT *s, size_type pos, size_type n ) const;
      size_type rfind( const CharT *s, size_type pos = npos ) const;
      size_type rfind( CharT c, size_type pos = npos ) const;

      size_type find_first_of( const basic_string &str, size_type pos = 0 ) const;
      size_type find_first_of( const CharT *s, size_type pos, size_type n ) const;
      size_type find_first_of( const CharT *s, size_type pos = 0 ) const;
      size_type find_first_of( CharT c, size_type pos = 0 ) const;

      size_type find_last_of( const basic_string &str, size_type pos = npos ) const;
      size_type find_last_of( const CharT *s, size_type pos, size_type n ) const;
      size_type find_last_of( const CharT *s, size_type pos = npos ) const;
      size_type find_last_of( CharT c, size_type pos = npos ) const;

      size_type find_first_not_of( const basic_string &str, size_type pos = 0 ) const;
      size_type find_first_not_of( const CharT *s, size_type pos, size_type n ) const;
      size_type find_first_not_of( const CharT *s, size_type pos = 0 ) const;
      size_type find_first_not_of( CharT c, size_type pos = 0 ) const;

      size_type find_last_not_of( const basic_string &str, size_type pos = npos ) const;
      size_type find_last_not_of( const CharT *s, size_type pos, size_type n ) const;
      size_type find_last_not_of( const CharT *s, size_type pos = npos ) const;
      size_type find_last_not_of( CharT c, size_type pos = npos ) const;

      basic_string substr( size_type pos = 0, size_type n = npos ) const;

    private:
      // 1. buffer has size total.
      // 2. buffer never shrinks.
      // 3. total >= filled + 1. The extra space is for a O(1) c_str().
      // 4. total is a power of two.
      // 5. buffer allocated with mem or a copy of mem.
      // 6. Every string has its own buffer (no reference counting).
      //
      Allocator mem;      // Object used to get and release memory.
      pointer   buffer;   // Points at start of string.
      size_type filled;   // Number of buffer slots with characters.
      size_type total;    // Total number of buffer slots.

      // This method encapsulates the memory allocation policy.
      pointer alloc( size_type required, size_type &found );
  };


  // ======================================
  // Specific typedefs for char and wchar_t
  // ======================================
  typedef basic_string< char > string;
  typedef basic_string< wchar_t > wstring;


  // ================================================================
  // Members of basic_string that are needed by the exception classes
  // ================================================================

  template< class CharT, class Traits, class Allocator >
  basic_string< CharT, Traits, Allocator >::pointer
    basic_string< CharT, Traits, Allocator >::alloc(
      size_type required,
      size_type &found )
  {
    pointer   result;
    size_type length = 8;

    // Find a power of two that produces a sufficient size.
    while( length < required ) length <<= 1;
    result = mem.allocate( length );

    // Update outputs only if allocation successful.
    found = length;
    return( result );
  }


  // basic_string( const Allocator & )
  // *********************************
  template< class CharT, class Traits, class Allocator >
  basic_string< CharT, Traits, Allocator >::basic_string(
    const Allocator &a ) : mem( a )
  {
    buffer = alloc(1, total);
    filled = 0;
  }


  // basic_string( const basic_string &, const Allocator & )
  // ***************************************************************
  template< class CharT, class Traits, class Allocator >
  basic_string< CharT, Traits, Allocator >::basic_string(
    const basic_string &other ) : mem( other.mem )
  {
    buffer = alloc( other.filled + 1, total );
    Traits::copy( buffer, other.buffer, other.filled );
    filled = other.filled;
  }


  // basic_string( const CharT *, const Allocator & )
  // ************************************************
  template< class CharT, class Traits, class Allocator >
  basic_string< CharT, Traits, Allocator >::basic_string(
    const CharT     *s,
    const Allocator &a ) : mem( a )
  {
    size_type result_length = Traits::length( s );
    buffer = alloc( result_length + 1, total );
    Traits::copy( buffer, s, result_length );
    filled = result_length;
  }


  // ~basic_string( )
  // ****************
  template< class CharT, class Traits, class Allocator >
  basic_string< CharT, Traits, Allocator >::~basic_string( )
  {
    // No need to destroy characters. CharT must be POD type.
    mem.deallocate( buffer, total );
  }


  // operator=( const basic_string & )
  // *********************************
  template< class CharT, class Traits, class Allocator >
  basic_string< CharT, Traits, Allocator > &
    basic_string< CharT, Traits, Allocator >::operator=(
      const basic_string &other )
  {
    if( this == &other ) return *this;

    // Prepare new buffer.
    pointer new_buffer = mem.allocate( other.total );
    Traits::copy( new_buffer, other.buffer, other.filled );

    // Commit.
    mem.deallocate( buffer, total );
    buffer = new_buffer;
    total  = other.total;
    filled = other.filled;
    return( *this );
  }


  // c_str( ) const
  // **************
  template< class CharT, class Traits, class Allocator >
  inline
  const CharT *basic_string< CharT, Traits, Allocator >::c_str( ) const
  {
    // Problematic if 'pointer' is an unusual type. (Not supposed to happen).
    buffer[filled] = CharT();
    return( buffer );
  }

} // namespace std

#endif
