/*
 *  zsocket.h
 */
#ifndef _ZSOCKET_H_INCLUDED
#define _ZSOCKET_H_INCLUDED

 /* Classes, constant IP addresses and netmasks  */

#define IN_CLASSA(i)     (((long)(i) & 0x80000000)==0)
#define IN_CLASSA_NET    0xff000000
#define IN_CLASSA_NSHIFT 24
#define IN_CLASSA_HOST   0x00ffffff
#define IN_CLASSA_MAX    128
#define IN_CLASSB(i)     (((long)(i) & 0xc0000000)==0x80000000)
#define IN_CLASSB_NET    0xffff0000
#define IN_CLASSB_NSHIFT 16
#define IN_CLASSB_HOST   0x0000ffff
#define IN_CLASSB_MAX    65536
#define IN_CLASSC(i)     (((long)(i) & 0xe0000000)==0xc0000000)
#define IN_CLASSC_NET    0xffffff00
#define IN_CLASSC_NSHIFT 8
#define IN_CLASSC_HOST   0x000000ff
#define INADDR_ANY       0x00000000
#define INADDR_LOOPBACK  0x7f000001
#define INADDR_BROADCAST 0xffffffff
#define INADDR_NONE      0xffffffff

/* Supported address families */

#define AF_UNSPEC        0               /* Other protocol */
#define AF_INET          2               /* Internet IP Protocol */

/* Supported socket types */

#define SOCK_STREAM      1               /* TCP connection */
#define SOCK_DGRAM       2               /* UDP connection */
#define SOCK_RAW         3               /* RAW connection */

/* Supported protocol types */

#define IPPROTO_IP       0
#define IPPROTO_ICMP     1
#define IPPROTO_IGMP     2
#define IPPROTO_GGP      3
#define IPPROTO_TCP      6
#define IPPROTO_PUP      12
#define IPPROTO_UDP      17
#define IPPROTO_IDP      22
#define IPPROTO_ND       77
#define IPPROTO_RAW      255

/* Supported socket levels */

#define SOL_SOCKET       256             /* Applied on all levels */
#define SOL_TCP          6               /* Applied on TCP level */
#define SOL_IP           0               /* Applied on IP level */

/* Supported options */

#define SO_DEBUG         0x0001          /* Turn on debugging info recording */
#define SO_ACCEPTCONN    0x0002          /* Socket was listening */
#define SO_REUSEADDR     0x0004          /*  Allow local address reuse */
#define SO_KEEPALIVE     0x0008          /* Keep connections alive */
#define SO_DONTROUTE     0x0010          /* Just use interface addresses */
#define SO_BROADCAST     0x0020          /* Permit sending of broadcast msgs */
#define SO_USELOOPBACK   0x0040          /* Bypass hardware when possible */
#define SO_LINGER        0x0080          /* Linger on close if data present */
#define SO_OOBINLINE     0x0100          /* Leave received OOB data in line */
#define SO_REUSEPORT     0x0200          /* Allow local address & port reuse */
#define SO_DONTLINGER    ~SO_LINGER      /* Do not linger on close */
#define SO_SNDBUF        0x1001          /* Send buffer size */
#define SO_RCVBUF        0x1002          /* Receive buffer size */
#define SO_SNDLOWAT      0x1003          /* Send low-water mark */
#define SO_RCVLOWAT      0x1004          /* Receive low-water mark */
#define SO_SNDTIMEO      0x1005          /* Send timeout */
#define SO_RCVTIMEO      0x1006          /* Receive timeout */
#define SO_ERROR         0x1007          /* Get error status and clear */
#define SO_TYPE          0x1008          /* Get socket type */

/* User settable IP options */

#define IP_TOS           1               /* Set IP type of service */
#define IP_TTL           2               /* Set IP time to live */

/* User settable TCP options */

#define TCP_NODELAY      1               /* Don't delay send to coalesce
                                            packets */
#define TCP_KEEPALIVE    2               /* Send KEEPALIVE probes when idle for
                                            keep alive time periodic ticks */

/* Socket send/receive flags */

#define MSG_OOB          1               /* Send/receive out-of-band data */
#define MSG_PEEK         2               /* Read data without removing it from
                                            queue */
#define MSG_DONTROUTE    4               /* Do not route packets */

/* IOCTL commands */

#define FIONREAD         0x4004667f       /* Returns number of bytes available
                                             for next read */
#define SIOCATMARK       0x40047307       /* Returns bolean reflecting
                                             out-of-band data read status */

/* Shutdown how arguments */

#define SD_RECEIVE       0                /* Shutdown receive operation */
#define SD_SEND          1                /* Shutdown send operation */
#define SD_BOTH          2                /* Shutdown both operations */

#ifndef FD_SETSIZE
#define FD_SETSIZE       64               /* Default fdset size */
#endif


#ifdef __cplusplus
extern "C" {
#endif /* __cplusplus */
#pragma pack(__push,1);

/* Some inline functions for converting between big and little endian */

unsigned long  htonl( unsigned long hostlong );
unsigned short htons( unsigned short hostshort );
unsigned long  ntohl( unsigned long netlong );
unsigned short ntohs( unsigned short netshort );
#pragma aux BSWAP "*" = "bswap eax" parm [eax] modify [eax];
#pragma aux XCHG "*"  = "xchg al,ah" parm [eax] modify [eax];
#pragma aux (BSWAP) htonl;
#pragma aux (BSWAP) ntohl;
#pragma aux (XCHG) htons;
#pragma aux (XCHG) ntohs;

/* For compatibility with Berkley sockets */

struct sockaddr
{
   unsigned short sa_family;
   char           sa_data[14];
};

/* For compatibility with Winsock applications */

struct in_addr
{
   union
   {
      struct { unsigned char s_b1, s_b2, s_b3, s_b4; } S_un_b;
      struct { unsigned short s_w1, s_w2; }            S_un_w;
      unsigned long                                    S_addr;
   } S_in;
};

/* Winsocks tries to remove some of the complexity above with this construction */

#define s_addr S_in.S_addr

/* A simplified construction of sockaddr used by Winsock */

struct sockaddr_in
{
   unsigned short sin_family;
   unsigned short sin_port;
   struct in_addr sin_addr;
   char           sin_zero[8];
};

/* We prefer the following construction to access sockaddr */

typedef struct
{
   unsigned short Family;
   unsigned short Port;
   unsigned int   Address;
   char           Zero[8];
} INET;

struct linger
{
   int l_onoff;
   int l_linger;
};

struct timeval
{
   long tv_sec;
   long tv_usec;
};

typedef struct
{
   unsigned int fd_count;
   int          fd_array[FD_SETSIZE];
} fd_set;

/* Socket functions */

int            accept( int s, struct sockaddr *addr, int *len );
int            bind( int s, const struct sockaddr *addr, int len );
int            closesocket( int s );
int            connect( int s, const struct sockaddr *addr, int len );
int            getpeername( int s, struct sockaddr *addr, int *len );
int            getsockname( int s, struct sockaddr *addr, int *len );
int            getsockopt( int s, int level, int opt, char *data, int *len );
int            ioctlsocket( int s, long cmd, unsigned long *value );
int            listen( int s, int backlog );
int            recv( int s, char *buf, int len, int flags );
int            recvfrom( int s, char *buf, int len, int flags,
                         struct sockaddr *addr, int *addrlen );
int            select( int nfds, fd_set *readfds, fd_set *writefds,
                       fd_set *exceptfds, const struct timeval *timeout );
int            send( int s, const char *buf, int len, int flags );
int            sendto( int s, const char *buf, int len, int flags,
                       const struct sockaddr *addr, int addrlen );
int            setsockopt( int s, int level, int opt, char *data, int len );
int            shutdown( int s, int how );
int            socket( int family, int type, int protocol );

/* Bit manipulation functions for fd_set */

void           fdclr( int s, fd_set *set );
void           fdset( int s, fd_set *set, int max );
void           fdzero( fd_set *set );
int            fdisset( int s, fd_set *set );

/* For winsock compatibility */

#define FD_CLR( fd, set )   fdclr( fd, set )
#define FD_SET( fd, set )   fdset( fd, set, FD_SETSIZE )
#define FD_ZERO( set )      fdzero( set )
#define FD_ISSET( fd, set ) fdisset( fd, set )

#pragma pack(__pop);
#ifdef __cplusplus
};
#endif /* __cplusplus */
#endif
