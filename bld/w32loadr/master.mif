!include cproj.mif

.asm: ..
.c: ..
.h: ..

.asm.obj:
  wasm -i.. -zq $<

cl = wcl$(host_CPU)

!ifeq host_OS dos

all: .SYMBOLIC #d4grun.exe x32run.exe tntrun.exe

dpmi_ldr.exe : loader16.obj dpmi_ldr.obj int21win.obj
  $(linker) system dos name dpmi_ldr file loader16,dpmi_ldr,int21win option map,quiet

# we don't need to link w386run with wstub.exe
# this will make it about 14k smaller
d4grun.exe : d4grun.obj cmain32.obj int21dos.obj
   $(linker) system dos4g name w386run file d4grun,cmain32,int21dos option stack=32k,map export DOS4GOPTIONS=_DOS4GOPTIONS
   $(rsi_root)\bin\4gbind $(rsi_root)\bin\dos4g.exe w386run.exe d4grun.exe -V
dbgrun.exe : d4grun.obj cmain32.obj int21dos.obj
   $(linker) d a system dos4g name dbgrun file d4grun,cmain32,int21dos option stack=32k,map,quiet
tntrun.exe : tntrun.obj cmain32.obj int21pl.obj
   $(linker) system pharlap ext name tntrun file tntrun,cmain32,int21pl option stack=32k,map,quiet
   $(%tntdir)\bin\rebind $(%tntdir)\bin\rtk\tntb.exe tntrun.exp -exe tntrun.exe
x32run.exe : x32run.obj cmain32.obj x32start.obj
   $(linker) format os2 lx name x32run file x32start,x32run,cmain32 lib x32b option map,dosseg,internalrelocs,stack=4k,quiet libpath $(lang_root)\lib386\dos;$(lang_root)\lib386
   x32fix x32run.exe
tntrun.obj : loader.c loader.h
        $(cc) $[@ /ox /d1 /d__DOS /d__CALL21__ /d__TNT /fo=$@ /zq
x32run.obj : loader.c loader.h
        $(cc) $[@ /ox /d1 /d__DOS /d__CALL21__ /d__X32 /fo=$@ /zq
d4grun.obj : loader.c loader.h dginfo.gh
        $(cc) $[@ /ox /d1 /d__DOS /d__CALL21__ /d__DOS4G /fo=$@ /zq
dginfo.gh : $(rsi_root)\bin\dos4g.exe
        @%write mkdginfo.bat $(rsi_root)\bin\dos4g $(rsi_root)\bin\dginfo >dginfo.gh
        -mkdginfo

dpmi.exe : dpmi.obj loader16.obj int21win.obj
        $(linker) system dos file dpmi,loader16,int21win option map,stack=8k,quiet
dpmi.obj : dpmi.asm
        wasm -zq -d2 $<
dos16m.obj : dos16m.asm
        wasm -zq -d2 $<

!else ifeq host_OS nt

all : w32bindnt.exe ntrunner.exe

w32bindnt.exe : w32bind.c
  $(cl) $[@ /zq /bt=NT /l=nt /fe=w32bindnt /ox

dbgntrun.exe : ntrun.obj cstrtwnt.obj int21.obj int21nt.obj ntstub.exe
  @%write tmp.lnk debug all
  @%append tmp.lnk sys nt name dbgntrun file cstrtwnt,ntrun,int21,int21nt opt map,stack=64k,stub=ntstub.exe,quiet
  @%append tmp.lnk lib nt
! ifdef tools_10_1
  @%append tmp.lnk lib kernel32,user32,gdi32,comdlg32,winspool,advapi32,shell32
! endif
  $(linker) @tmp.lnk

ntrun.exe : ntrun.obj cstrtwnt.obj int21.obj int21nt.obj ntstub.exe
  @%write tmp.lnk sys nt name ntrun file cstrtwnt,ntrun,int21,int21nt opt map,stack=64k,stub=ntstub.exe,quiet
  @%append tmp.lnk lib nt,kernel32
! ifdef tools_10_1
  @%append tmp.lnk lib kernel32,user32,gdi32,comdlg32,winspool,advapi32,shell32
! endif
  $(linker) @tmp.lnk
  del tmp.lnk
  for %i in ( $(nt_exes) ) do copy ntrun.exe nt\%i

ntrunner.exe : ntrunner.obj cstrtwnt.obj int21.obj int21nt.obj ntstub.exe
  @%write tmp.lnk sys nt name ntrunner.exe file cstrtwnt, ntrunner,int21,int21nt opt map,stack=64k,stub=ntstub.exe,quiet
  @%append tmp.lnk lib nt,kernel32
! ifdef tools_10_1
  @%append tmp.lnk lib kernel32,user32,gdi32,comdlg32,winspool,advapi32,shell32
! endif
  $(linker) @tmp.lnk
  del tmp.lnk

ntstub.exe : ntstub.obj
  $(linker) system dos file ntstub option map,quiet

int21nt.obj : int21nt.c
  $(cc) $[@ /ox /d1 /bt=NT /zq /i$(watcom_nt_h)
ntrun.obj : loader.c loader.h
  $(cc) $[@ /ox /d1 /bt=NT /d__NT /d__CALL21__ /fo=ntrun.obj /zq /i$(watcom_nt_h)
ntrunner.obj : loader.c loader.h
  $(cc) $[@ /ox /d1 /bt=NT /d__NT /d__CALL21__ /dW32RUN /fo=ntrunner.obj /zq /i$(watcom_nt_h)

!else ifeq host_OS os2

all: w32bind.exe os2ldr.exe

w32bind.exe : w32bind.c
  $(cl) $< /ox /zq /"option stub=wstubq"

os2ldr.exe : cstrtos2.obj loader.obj int21.obj int21os2.obj tnk.obj os2stub.exe
  $(linker) system os2v2 pmc name os2ldr file cstrtos2,loader,int21,int21os2,tnk lib os2386 opt map,stack=32k,stub=os2stub.exe,quiet

os2stub.exe : loader16.obj dpmildr.obj int21win.obj
  $(linker) system dos name os2stub file loader16,dpmildr,int21win option map,quiet

loader.obj : loader.c loader.h
        $(cc) $[@ /ox /d1 /d__OS2 /d__CALL21__ /zq /i$(inc_dirs_sys_os2_386)
int21os2.obj : int21os2.c
        $(cc) $[@ /ox /d1 /zq /i$(inc_dirs_sys_os2_386)

!endif

int21win.obj : int21win.asm
        wasm -zq -d2 $<

clean: .SYMBOLIC
        @if exist *.exe @del *.exe
        @if exist *.exp @del *.exp
        @if exist *.obj @del *.obj
        @if exist *.map @del *.map
        @if exist *.gh @del *.gh
        @if exist mkdginfo.bat @del mkdginfo.bat
        @if exist a*. @del a*.
