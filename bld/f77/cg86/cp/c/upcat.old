//
// UPCAT        : UPSCAN concatenation sequences
//

// maybe required by 370 and VAX versions

#include "ftnstd.h"
#include "opr.h"
#include "opn.h"
#include "errcod.h"
#include "global.h"

extern  void            BackTrack(void);
extern  void        EvalOpn(void);
extern  void            PushOpn(itnode *);
extern  void            AddConst(itnode *);
extern  void            ConstCat(int);
extern  sym_id          GStartCat(int,int);
extern  void            GStopCat(int,sym_id);
extern  void            AdvanceITPtr(void);
extern  bool            ReqNOpn(void);
extern  void            FreeOneNode(itnode *);
extern  void            FreeITNodes(itnode *);
extern  void            GCatArg(itnode *);
extern  void            OpndErr(int);
extern  void            TypeTypeErr(int,uint,uint);
extern  void            TypeErr(int,uint);
extern  bool            RecOpenParen(void);
extern  bool            RecCloseParen(void);
extern  void        Error(int,...);
extern  void        KillOpnOpr(void);
extern  void        MoveDown(void);


void        CatOpn() {
//========================

// Process a concatenation operand.

    EvalOpn();
}


void        FoldCat() {
//=========================

// Fold all sequences of character constants.

    itnode      *cit;

    cit = CITNode;
    for(;;) {
        cit = FoldCatSequence( cit );
        if( cit->opr != OPR_CAT ) break;
    }
}


static  itnode  *FoldCatSequence( itnode *cit ) {
//===============================================

// Fold a sequnece of character constants.

    uint        size;
    uint        num;
    itnode      *save;

    save = CITNode;
    CITNode = cit;
    num = 0;
    size = 0;
    for(;;) {
        if( cit->opn != OPN_CON ) break;
        num++;
        size += cit->value.cstring.len;
        cit = cit->link;
        if( cit->opr != OPR_CAT ) break;
    }
    if( num > 1 ) {
        ConstCat( size );
    }
    if( num == 0 ) {
        cit = cit->link;
    }
    CITNode = save;
    return( cit );
}


void        FiniCat() {
//=========================

// Finish concatenation.

    int         num;
    sym_id      result;
    int         size;

    FoldCat();
    num = ScanCat( &size );
    if( num != 1 ) {
        result = GStartCat( num, size );
        CatArgs( num );
        CITNode->size = size;
        GStopCat( num, result );
    }
}


int     AsgnCat() {
//=========================

// Get character operand to assign.

    return( ScanCat( NULL ) );
}


static  int     ScanCat( int *size_ptr ) {
//========================================

// Scan for strings to be concatenated.

    uint        cat_size;
    itnode      *itptr;
    uint        num_cats;

    itptr = CITNode;
    cat_size = 0;
    num_cats = 0;
    for(;;) {
        if( CITNode->opn == OPN_PHI ) {
            // no operand (A = B // // C)
            TypeErr( SX_WRONG_TYPE, TY_CHAR );
        } else if( CITNode->typ != TY_CHAR ) {
            TypeTypeErr( MD_MIXED, TY_CHAR, CITNode->typ );
        } else if( ( CITNode->size == 0 ) && ( size_ptr != NULL ) ) {
            // NULL 'size_ptr' means we are concatenating into a character
            // variable so character*(*) variables are allowed.
            OpndErr( CV_BAD_LEN );
        } else {
            cat_size += CITNode->size;
        }
        CITNode = CITNode->link;
        num_cats++;
        if( CITNode->opr != OPR_CAT ) break;
    }
    CITNode = itptr;
    if( size_ptr != NULL ) {
        *size_ptr = cat_size;
    }
    return( num_cats );
}


void        CatBack() {
//=========================

// Scan back on = // sequence if RHS is a char expression.
// All parens and lists must have been removed already.
// Consider:    l = a//b .eq. c//d
//                  vs
//              c = x//y//z


    itnode      *itptr;

    itptr = CITNode->link->link; // point one operator past "//"
    for(;;) {
        if( itptr->opr == OPR_TRM ) break;
        if( itptr->opr != OPR_CAT ) {
            FiniCat();
            return;
        }
        itptr = itptr->link;
    }
    FoldCat();
    BackTrack(); // eg : a = b//c//d//e
}


void        CatAxeParens() {
//==============================

// Remove LBR and matching RBR on ( // sequence.
// OPR_FBR's will not be found since lists are detached
//
// Before:                            |   After:
//                ---------------     |                 ---------------
//                | opr1 | PHI  |     |                    released**
//                ---------------     |                 ---------------
//       CIT ==>  | (    | opn2 |     |        CIT ==>  | opr1 | opn2 |
//                ---------------     |                 ---------------
//                | //   | opn3 |     |                 | //   | opn3 |
//                ---------------     |                 ---------------
//                      ...           |                       ...
//                ---------------     |                 ---------------
//                |  )   | PHI  |     |                    released**
//                ---------------     |                 ---------------
//
//  ** see KillOpnOpr() for case where first node is start-node of expr

    itnode      *cit;
    itnode      *chaser;
    int         num;

    BackTrack();    // Consider:    a = 1(a//2)
    ReqNOpn();      //    ...
    MoveDown();     //    ...
    KillOpnOpr();
    cit = CITNode;
    num = 1;
    while( num != 0 ) {
        chaser = CITNode;
        if( chaser->link == NULL ) break;
        AdvanceITPtr();
        if( RecOpenParen() ) {
            num++;
        } else if( RecCloseParen() ) {
            num--;
        }
    }
    if( num != 0 ) {
        CITNode = cit;
        Error( PC_UNMATCH_PAREN );
    } else {
        ReqNOpn();  // catch it here since RemoveParen won't get called
        chaser->link = CITNode->link;
        FreeOneNode( CITNode );
        CITNode = cit;
    }
}


void        CatParen() {
//==========================

// Check if ) is for a substring operand.

    BackTrack();
}


void        CatArgs( int num ) {
//==================================

// Generate code for concatenation arguments.

    itnode      *itptr;
    itnode      *junk;
    int         count;

    itptr = CITNode;
    count = num;
    for(;;) {
        if( itptr->opn == OPN_CON ) {
            AddConst( itptr );
        }
        // Don't call CatArg() if no operand or not of type character
        if( ( itptr->opn != OPN_PHI ) && ( itptr->typ == TY_CHAR ) ) {
            GCatArg( itptr );
        }
        if( --count <= 0 ) break;
        itptr = itptr->link;
    }
    if( CITNode != itptr ) {
        junk = CITNode->link;
        CITNode->link = itptr->link;
        itptr->link = NULL;
        FreeITNodes( junk );
    }
}
