;*****************************************************************************
;*
;*                            Open Watcom Project
;*
;*    Portions Copyright (c) 1983-2002 Sybase, Inc. All Rights Reserved.
;*
;*  ========================================================================
;*
;*    This file contains Original Code and/or Modifications of Original
;*    Code as defined in and that are subject to the Sybase Open Watcom
;*    Public License version 1.0 (the 'License'). You may not use this file
;*    except in compliance with the License. BY USING THIS FILE YOU AGREE TO
;*    ALL TERMS AND CONDITIONS OF THE LICENSE. A copy of the License is
;*    provided with the Original Code and Modifications, and is also
;*    available at www.sybase.com/developer/opensource.
;*
;*    The Original Code and all software distributed under the License are
;*    distributed on an 'AS IS' basis, WITHOUT WARRANTY OF ANY KIND, EITHER
;*    EXPRESS OR IMPLIED, AND SYBASE AND ALL CONTRIBUTORS HEREBY DISCLAIM
;*    ALL SUCH WARRANTIES, INCLUDING WITHOUT LIMITATION, ANY WARRANTIES OF
;*    MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE, QUIET ENJOYMENT OR
;*    NON-INFRINGEMENT. Please see the License for the specific language
;*    governing rights and limitations under the License.
;*
;*  ========================================================================
;*
;* Description:  WHEN YOU FIGURE OUT WHAT THIS FILE DOES, PLEASE
;*               DESCRIBE IT HERE!
;*
;*****************************************************************************


;
; FCFLIP        : Support for reversing operands on the stack
;

include fcdef.inc

        fmodstart       fcflip

        SaveESI         DD      0
        SaveEBP         DD      0

fcode   II_FLIP
dfcode  RI_FLIP
dfcode  IR_FLIP
dfcode  RR_FLIP
        pop     eax             ; pop op 1
        pop     edx             ; pop op 2
        push    eax             ; push op 1
        push    edx             ; push op 2
        next
efcode  II_FLIP


fcode   DI_FLIP
dfcode  CI_FLIP
dfcode  DR_FLIP
dfcode  CR_FLIP
        pop     eax             ; pop op 1
        pop     edx             ; ...
        pop     ebx             ; pop op 2
        push    edx             ; push op 1
        push    eax             ; ...
        push    ebx             ; push op 2
        next
efcode  DI_FLIP


fcode   ID_FLIP
dfcode  IC_FLIP
dfcode  RD_FLIP
dfcode  RC_FLIP
        pop     eax             ; pop op 1
        pop     ebx             ; pop op 2
        pop     ecx             ; ...
        push    eax             ; push op 1
        push    ecx             ; push op 2
        push    ebx             ; ...
        next
efcode  ID_FLIP


fcode   DD_FLIP
dfcode  CD_FLIP
dfcode  DC_FLIP
dfcode  CC_FLIP
        pop     eax             ; pop op 1
        pop     edx             ; ...
        pop     ebx             ; pop op 2
        pop     ecx             ; ...
        push    edx             ; push op 1
        push    eax             ; ...
        push    ecx             ; push op 2
        push    ebx             ; ...
        next
efcode  DD_FLIP


fcode   IQ_FLIP
dfcode  RQ_FLIP
dfcode  IE_FLIP
dfcode  RE_FLIP
        pop     edi             ; pop op 1
        pop     eax             ; pop op 2
        pop     ebx             ; ...
        pop     ecx             ; ...
        pop     edx             ; ...
        push    edi             ; push op 1
        push    edx             ; push op 2
        push    ecx             ; ...
        push    ebx             ; ...
        push    eax             ; ...
        next
efcode  IQ_FLIP


fcode   IX_FLIP
dfcode  RX_FLIP
        mov     eax, [esp]      ; pop op 1
        mov     ebx, esi        ; save the fcode pointer
        lea     esi, esp+4      ; shift down the entire xcomplex down 4
        mov     edi, esp        ; ...
        movsd                   ; ...
        movsd                   ; ...
        movsd                   ; ...
        movsd                   ; ...
        movsd                   ; ...
        movsd                   ; ...
        movsd                   ; ...
        movsd                   ; ...
        mov     [edi], eax      ; kick up the four byte value
        mov     esi, ebx        ; restore the fcode pointer
        next
efcode  IX_FLIP


fcode   XI_FLIP
dfcode  XR_FLIP
        mov     eax, 32[esp]    ; pop op 2
        mov     ebx, esi        ; save the fcode pointer
        lea     esi, esp+28     ; shift up the entire xcomplex down 4
        lea     edi, esp+32     ; ...
        std                     ; decrement registers, instead of increment
        movsd                   ; ...
        movsd                   ; ...
        movsd                   ; ...
        movsd                   ; ...
        movsd                   ; ...
        movsd                   ; ...
        movsd                   ; ...
        movsd                   ; ...
        mov     [esp], eax      ; put back the 4 byte quattity
        mov     esi, ebx        ; restore the fcode pointer
        cld                     ; restore increment flag
        next
efcode  XI_FLIP


fcode   DQ_FLIP
dfcode  CQ_FLIP
dfcode  DE_FLIP
dfcode  CE_FLIP
        pop     edi             ; pop op 1
        pop     edx             ; ...
        pop     eax             ; pop op 2
        pop     ebx             ; ...
        pop     ecx             ; ...
        xchg    [esp],edx       ; get last part of op 2 and begin pushing op 1
        push    edi             ; push op 1
        push    edx             ; push op 2
        push    ecx             ; ...
        push    ebx             ; ...
        push    eax             ; ...
        next
efcode  DQ_FLIP


fcode   DX_FLIP
dfcode  CX_FLIP
        mov     eax,[esp]       ; load op 1
        mov     edx,4[esp]      ; ...
        mov     ebx, esi        ; save the fcode pointer
        lea     esi, esp+8      ; shift down the entire xcomplex down 4
        mov     edi, esp        ; ...
        movsd                   ; ...
        movsd                   ; ...
        movsd                   ; ...
        movsd                   ; ...
        movsd                   ; ...
        movsd                   ; ...
        movsd                   ; ...
        movsd                   ; ...
        mov     [edi], eax      ; kick up the 8 byte value
        mov     4[edi], edx     ; ...
        mov     esi, ebx        ; restore the fcode pointer
        next
efcode  DX_FLIP


fcode   XD_FLIP
dfcode  XC_FLIP
        mov     eax, 32[esp]    ; pop op 2
        mov     edx, 36[esp]    ; ...
        mov     ebx, esi        ; save the fcode pointer
        lea     esi, esp+28     ; shift up the entire xcomplex down 4
        lea     edi, esp+36     ; ...
        std                     ; decrement registers, instead of increment
        movsd                   ; ...
        movsd                   ; ...
        movsd                   ; ...
        movsd                   ; ...
        movsd                   ; ...
        movsd                   ; ...
        movsd                   ; ...
        movsd                   ; ...
        mov     [esp], eax      ; put back the 8 byte quattity
        mov     4[esp], edx     ; ...
        mov     esi, ebx        ; restore the fcode pointer
        cld                     ; restore increment flag
        next
efcode  XD_FLIP


fcode   QI_FLIP
dfcode  QR_FLIP
dfcode  EI_FLIP
dfcode  ER_FLIP
        pop     eax             ; pop op 1
        pop     ebx             ; ...
        pop     ecx             ; ...
        pop     edx             ; ...
        pop     edi             ; pop op 2
        push    edx             ; push op 1
        push    ecx             ; ...
        push    ebx             ; ...
        push    eax             ; ...
        push    edi             ; push op 2
        next
efcode  QI_FLIP


fcode   QD_FLIP
dfcode  QC_FLIP
dfcode  ED_FLIP
dfcode  EC_FLIP
        pop     eax             ; pop op 1
        pop     ebx             ; ...
        pop     ecx             ; ...
        pop     edx             ; ...
        pop     edi             ; pop op 2
        xchg    [esp],edx       ; get rest of op 2 and start pushing op 1
        push    ecx             ; cont pushing op 1
        push    ebx             ; ...
        push    eax             ; ...
        push    edx             ; push op 2
        push    edi             ; ...
        next
efcode  QD_FLIP


fcode   QQ_FLIP
dfcode  EE_FLIP
dfcode  QE_FLIP
dfcode  EQ_FLIP
        pop     eax             ; pop op 1
        pop     ebx             ; ...
        pop     ecx             ; ...
        pop     edx             ; ...
        pop     edi             ; pop op 2 (partially)
        xchg    8[esp],edx      ; push op 1 and get rest of op 2
        xchg    4[esp],ecx      ; ...
        xchg    [esp],ebx       ; ...
        push    eax             ; ...
        push    edx             ; push op 2
        push    ecx             ; ...
        push    ebx             ; ...
        push    edi             ; ...
        next
efcode  QQ_FLIP


fcode   QX_FLIP
dfcode  EX_FLIP
        mov     eax,[esp]       ; load op 1
        mov     ebx,4[esp]      ; ...
        mov     ecx,8[esp]      ; ...
        mov     edx,12[esp]     ; ...
        push    esi             ; save fcode ptr
        lea     esi, esp+20     ; shift down the entire xcomplex down 4
        lea     edi, esp+4      ; ...
        movsd                   ; ...
        movsd                   ; ...
        movsd                   ; ...
        movsd                   ; ...
        movsd                   ; ...
        movsd                   ; ...
        movsd                   ; ...
        movsd                   ; ...
        mov     [edi], eax      ; kick up the 16 byte value
        mov     4[edi], ebx     ; ...
        mov     8[edi], ecx     ; ...
        mov     12[edi], edx    ; ...
        pop     esi             ; restore the fcode pointer
        next
efcode  QX_FLIP


fcode   XQ_FLIP
dfcode  XE_FLIP
        mov     eax, 32[esp]    ; pop op 2
        mov     edx, 36[esp]    ; ...
        mov     edx, 40[esp]    ; ...
        mov     edx, 44[esp]    ; ...
        push    esi             ; save the fcode pointer
        lea     esi, esp+32     ; shift up the entire xcomplex down 4
        lea     edi, esp+44     ; ...
        std                     ; decrement registers, instead of increment
        movsd                   ; ...
        movsd                   ; ...
        movsd                   ; ...
        movsd                   ; ...
        movsd                   ; ...
        movsd                   ; ...
        movsd                   ; ...
        movsd                   ; ...
        mov     4[esp], eax     ; put back the 16 byte quattity
        mov     8[esp], ebx     ; ...
        mov     12[esp], ecx    ; ...
        mov     16[esp], edx    ; ...
        pop     esi             ; restore the fcode pointer
        cld                     ; restore increment flag
        next
efcode  XQ_FLIP


fcode   XX_FLIP
        mov     eax, 12[esp]    ; load op 1
        mov     ebx, 16[esp]    ; ...
        mov     ecx, 20[esp]    ; ...
        mov     edx, 24[esp]    ; ...
        mov     edi, 28[esp]    ; ...
        xchg    edi,60[esp]     ; xchng with op 2
        xchg    edx,56[esp]     ; ...
        xchg    ecx,52[esp]     ; ...
        xchg    ebx,48[esp]     ; ...
        xchg    eax,44[esp]     ; ...
        mov     12[esp],eax     ; save op 1
        mov     16[esp],ebx     ; ...
        mov     20[esp],ecx     ; ...
        mov     24[esp],edx     ; ...
        mov     28[esp],edi     ; ...
        mov     eax, [esp]      ; load op 1
        mov     ebx, 4[esp]     ; ...
        mov     ecx, 8[esp]     ; ...
        xchg    ecx,40[esp]     ; xchng with op 2
        xchg    ebx,36[esp]     ; ....
        xchg    eax,32[esp]     ; ....
        mov     [esp],eax       ; save op 1
        mov     4[esp],ebx      ; ...
        mov     8[esp],ecx      ; ...
        next
efcode  XX_FLIP

        fmodend
        end
