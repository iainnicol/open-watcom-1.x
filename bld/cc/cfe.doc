
        C Front End Notes
        -----------------
1. There used to be two implementations: TREE and QUAD. The old quads
   and leafs version used to represent expressions as quads, ie:

   result = operand1 operator operand2

   All new development has been done on the TREE version which represents
   expressions as trees, and the old QUAD version was eventually retired.

   The TREE version introduced some new source files with suffix 2. e.g.
   cexpr2.c cfold2.c cmath2.c cgen2.c cstmt2.c.

2. Major header files
   The major header files are cvars.h, ctypes.h and cops.h. Most source
   files need only include cvars.h.
   CVARS.H      - primary include file. The file includes most of the
                  other header files. Most global data variables are
                  declared here using the GLOBAL macro. All function
                  prototypes are also in this file.
   CTYPES.H     - defines common data structures, enum constants
   COPS.H       - defines parse tree operators and parse tree data structures
   CERRS.H      - error messages

3. Adding a new keyword:
   - CC\H directory contains 4 files containing list of keywords
   C.KEY     - normal standard C keywords
   SEH.KEY   - keywords for structured exception handling
   PC.KEY    - keywords generally associated with PC implementations

   e.g. to add __int64 as a keyword
   - add entry to PC.KEY
     The second column indicates what token class this new token
     belongs to. Token classes start with TC_ and can be found in
     CTOKENS.H. Since 'int' and 'long' are listed as TC_KEYWORD,
     we should make '__int64' a TC_KEYWORD.
   - delete an entry from DUMMY.KEY (to keep total power of 2)
   - wmake will run findhash which tries to find a perfect hash for
     the list of keywords it is given. If it is successful, it will
     create 2 files: WEIGHTS.GH and KEYWORDS.GH
   - Since findhash usually ends up assigning new token values for
     all the keywords when a new one is added, you SHOULD do a global
     recompile after adding/removing a keyword. MASTER.MIF should be
     modified to make this automatic.

4. Adding a new error message:
   All error messages are added to CERRS.H. There are several groups:
   - warning level 1
   - warning level 2
   - warning level 3
   - errors
   The warning levels are defined using the warn() macro at the top of
   the file. Different macros are used for each group of messages:
   Message Group        Macro
   -------------        -----
   warning level 1      err1
   warning level 2      err2
   warning level 3      err3
   errors               err9

   The following is an example of a message entry: Note that there is
   no comma between the E("english message") and J("japanese message")
   macros. Additional language translations can be added by adding
   additional entries: e.g. German messages could be added by adding a
   G("german message") entry to every message.
   CMSG.C is where the arrays of error messages are initialized. This
   has NOT been done yet, BUT when we get the Japanese translations,
   CMSG.C needs to be modified to include CERRS.H a second time with
   appropriate definitions for the macros to cause the J() messages to
   be selected while ignoring the E() messages. Code also needs to be
   added to select at execution time which translation to display.
   Brian knows what the code sequence should be. There is a global
   variable that is updated by the OSI loader that can be used to
   select the appropriate translation.
   NOTE: We are still waiting for the Japanese translations.

err2(   ERR_DEAD_CODE,                  <- enum constant used in code
        E("Unreachable code" )          <- english error message
        J("Unreachable code" )          <- japanese error message
),
#ifdef GML                              <- GML description for manual
.np
The statement will never be executed, because there is no path through
the program that causes control to reach this statement.
#endif

   The GML portion of the file is enclosed in #ifdef GML, #endif pairs.
   The file mkgml.c is used to extract the GML portions of the file and
   create the neccesary GML files for the manual and help files.

   New messages should always be added at the end of the appropriate
   group of messages so that the message numbers do not change from
   one release to the next.
