.continue
.erase

.EXTENSIONS:
.EXTENSIONS:  .exe .exp .lib .obj .cpp .c .asm .h .gh .mif

.mif: $(mif_path)

proj_name = cc

!include cproj.mif
!include deftarg.mif
!include defrule.mif

!include mlibs.mif
!include binname.mif

# CODEGEN stuff
!include $(cg_dir)/mif/fe.mif
!include $(cg_dir)/mif/hostos.mif

!ifdef bootstrap
cg_inc_dirs = -I$(cfloat_dir)/h -I$(watcom_dir)/h -I$(owl_dir)/h &
  -I$(cg_dir)/h -I$(cg_dir)/intel/h -I$(cg_dir)/intel/$(target_CPU)/h
!endif


!ifndef cc_version
cc_version      = tree
!endif

!ifndef patch_level
patch_level=0
!endif

extra_c_flags_386= -3r -fpc

!ifeq cg_dll 1
extra_c_flags = -D_CGDLL
!endif

defines_tree    = -DNEWCFE

defines = $(defines_$(cc_version)) -Dlocal=static
# international data files
intname = wcc$(target_cpu)

!ifndef bootstrap
!ifeq release 1
opts_cscan_386  = -5r
extra_c_flags_cscan = $(opts_cscan_$(host_cpu))
!endif
!endif
extra_c_flags_cgen386 = -DBY_C_FRONT_END
extra_c_flags_idedll  = -bd
!ifdef __LINUX__
extra_c_flags_intlload = -D__header=\"fesupp.h\"
!else
extra_c_flags_intlload = -D__header="fesupp.h"
!endif
extra_c_flags_cmsg = -D__target_CPU=$(intname)
opts_cdata_nt = -DLARGEST_QUAD_INDEX=500
opts_cdata_os2 = -DLARGEST_QUAD_INDEX=500
extra_c_flag_cdata = $(opts_cdata_$(host_OS))

# WASM stuff
!ifeq target_cpu axp
inline_asm_dir = $(as_dir)
inline_asm_h = $(as_dir)/alpha/h;$(as_dir)/h;$(owl_dir)/h
!else
!ifeq target_cpu ppc
inline_asm_dir = $(as_dir)
inline_asm_h = $(as_dir)/ppc/h;$(as_dir)/h;$(owl_dir)/h
!else
!include $(wasm_dir)/mif/inline.mif
inline_asm_dir = $(wasm_dir)
inline_asm_h = $(wasm_dir)/h
pre_deps_wasm = inlnops.gh
extra_a_flags_codei86 = -i"$(watcom_dir)/h"
extra_a_flags_code386 = -i"$(watcom_dir)/h"
!endif
!endif

#dwarf stuff
!include $(dwarf_dir)/dw/client.mif
dwarf_deps = $(dwarf_dw_dep)
dwarf_lib  = $(dwarf_dw_lib)

#dll test driver
#wcc386t.exe
cdrv_objs = cdrvdll.obj

#host dependant goop
pre_deps_qnx = wcc.u
pre_deps_osi = $(tools_root)/os2ldr.exe

# other goofy stuff
pre_obj_deps = $(pre_deps_wasm) $(pre_deps_$(host_os)) code$(target_cpu).gh &
        usage.gh msgtxt.gh msgdefs.gh msgattr.gh weights.gh keywords.gh

pre_obj_deps += $(intname)01.int

#
# NOTE: "op off=?" must be 8K bigger than the stack size in wlink_sys_qnx_f
#
extra_l_flags_qnx= option stack=16k,offset=24k, res=wcc.u, priv=3
extra_l_flags_nt = option stack=1024k commit stack=32k
extra_l_flags_dos = option stack=32k

extra_l_flags = option map

# final executable extensions for the various hosts
final_exe_dos   = exe
final_exe_os2   = exe
final_exe_osi   = exe
final_exe_nt    = exe
final_exe_qnx   = qnx
final_exe_linux = elf

# WLINK .DLL options for the various hosts
wlink_dll_os2           = option manyautodata
wlink_dll_nt            = option offset=0x69400000
wlink_opt_os2_386_dll   = sys os2v2 dll
wlink_opt_nt_386_dll    = sys nt_dll
wlink_opt_nt_axp_dll    = sys ntaxp_dll

# 1 if we use asinline_lib to do inline assembly
as_lib_ppc      = 1
as_lib_axp      = 1

xname = $(bin_dir)/wcc$(target_cpu)c.$(final_exe_$(host_os))
dxname = $(bin_dir)/wcc$(target_cpu)d.$(final_exe_$(host_os))
dllexet = $(bin_dir)/wcc$(target_cpu)t
dllexe = $(bin_dir)/wcc$(target_cpu)e
dllname = $(bin_dir)/wccd$(target_cpu)e
cxname = $(bin_dir)/wcc$(target_cpu)s.$(final_exe_$(host_os))

# systems where version resources must be added to .DLL
build_rc_nt_386 = nt

!ifdef bootstrap
inc_dirs = -I. -I../h
inc_dirs += -I$(cc_dir)/h $(cg_inc_dirs)
inc_dirs += -I$(inline_asm_h)
inc_dirs += -I$(dwarf_dir)/dw/h
inc_dirs += -I$(comp_cfg_dir)/h
inc_dirs += -I$(fe_misc_dir)/h

ldflags = -L$(clib_dir)/$(%OBJDIR) -L$(wres_dir)/$(%OBJDIR) 
libs = $(dwarf_dir)/dw/$(%OBJDIR)/dwf.lib -lwatcom -lwres

!else

inc_dirs =.;
inc_dirs +=$(cc_dir)/h;$(cg_inc_dirs);
inc_dirs +=$(inline_asm_h);
inc_dirs +=$(dwarf_dir)/dw/h;
inc_dirs +=$(comp_cfg_dir)/h;
inc_dirs +=$(fe_misc_dir)/h

!endif

.BEFORE
        @set INCLUDE=$(inc_path)

.c: $(cc_dir)/c;$(inline_asm_dir)/c;$(watcom_dir)/c;$(fe_misc_dir)/c
.h: $(cc_dir)/h;$(inline_asm_h);$(watcom_dir)/h
.gh: $(cc_dir)/h

extra_c_flags += $(defines)

!ifdef bootstrap
def_targ = wcc$(target_CPU)
!endif
!ifndef def_targ
!ifdef on_build_machine
def_targ_os2    = $(dllexe).exe
def_targ_nt     = $(dllexe).exe
def_targ        = $(xname)
!else
def_targ_os2    = $(dllexe).exe
def_targ_nt     = $(dllexe).exe
def_targ        = $(dxname)
!endif
!ifdef def_targ_$(host_os)
def_targ        = $(def_targ_$(host_os))
!endif
!endif

target: $(def_targ) .SYMBOLIC
        @%null

# Our stuff
!include $(cc_dir)/deps.mif
!include $(cc_dir)/ccobjs.mif

!ifdef bootstrap
xname = wcc$(target_cpu)
dwarf_deps =
!endif

$(xname): eraseall.obj $(pre_obj_deps) $(cc_objs) $(dwarf_deps) $(cg_deps) $(cc_dir)/ccobjs.mif
!ifdef bootstrap
	$(cc) $(ldflags) -o $@ $(cc_objs) $(libs) $(cg_deps)
!else
        @%make linkfile
        @%append $^&.lnk $(cg_libs)
        $(linker) $(lflags) @$^&.lnk
!ifeq   host_os osi
        $(bld_bin)/w32bind $^&.rex $^&.exe $(bld_bin)/os2ldr.exe
        rm -f $^&.rex
!endif
!ifeq   host_os qnx
!ifdef  on_build_machine
        serialize $(xname) wcc
!endif
!endif
!endif

$(dxname): eraseall.obj $(pre_obj_deps) $(cc_objs) $(dwarf_deps) $(cg_debug_deps) $(cc_dir)/ccobjs.mif
        @%make linkfile
        @%append $^&.lnk $(cg_debug_libs)
        $(linker) $(lflags) @$^&.lnk

$(cxname): eraseall.obj $(pre_obj_deps) $(cc_objs) $(dwarf_deps) $(cg_stub_deps) $(cc_dir)/ccobjs.mif
        @%make linkfile
        @%append $^&.lnk $(cg_stub_libs)
        $(linker) $(lflags) @$^&.lnk
!ifeq   host_os osi
        $(bld_bin)/w32bind $^&.rex $^&.exe $(tools_root)/os2ldr.exe
        rm -f $^&.rex
!endif
!ifeq   host_os qnx
!ifdef  on_build_machine
        serialize $(cxname) wcc
!endif
!endif

!ifdef build_rc_$(host_os)_$(host_cpu)
rc_objs = cc.rc
!endif

#
# Note this is just hammered in cause I don't know what
# I'm doing
#
$(dllname).dll : $(pre_obj_deps) $(rc_objs) $(dll_objs) $(dwarf_deps) $(cg_debug_deps) $(cc_dir)/ccobjs.mif
        @if exist $^&.lnk @rm -f $^&.lnk
        @%write $^&.lnk name $@
        @%append $^&.lnk OP map
        @%append $^&.lnk OP caseexact
        @%append $^&.lnk OP SYMFILE
        @%append $^&.lnk  $(wlink_opt_$(host_os)_$(host_cpu)_dll) initinstance terminstance
        @%append $^&.lnk $(wlink_dll_$(host_os))
        @%append $^&.lnk $(wlink_opt_common)
        @for %i in ( $(dll_objs) ) do @%append $^&.lnk file %i
        @%append $^&.lnk lib $(dwarf_lib)
!ifdef as_lib_$(target_cpu)
        @%append $^&.lnk lib $(asinline_axp_lib)
!endif
!ifdef  on_build_machine
        @%append $^&.lnk $(cg_libs)
!else
        @%append $^&.lnk $(cg_debug_libs)
!endif
        $(linker) $(ldebug_$(host_cpu))  @$^&.lnk
!ifdef build_rc_$(host_os)_$(host_cpu)
        $(rc) -q -bt=$(build_rc_$(host_os)_$(host_cpu)) cc.rc $^@
!endif

$(dllname).lib : $(dllname).dll
    @if exist $(dllname).lib @rm -f $(dllname).lib
    $(librarian) -n -c $(dllname).lib +$(dllname).dll

$(dllexet).exe : $(cdrv_objs) $(dllname).lib
        @if exist $^&.lnk @rm -f $^&.lnk
        @%write $^&.lnk name $@
        @for %i in ( $(cdrv_objs) ) do @%append $^&.lnk file %i
        @%append $^&.lnk lib $(dllname).lib
        $(linker) $(lflags) @$^&.lnk

$(dllexe).exe : $(dlldrv_obj) $(dllname).lib
        @if exist $^&.lnk @rm -f $^&.lnk
        @%write $^&.lnk name $@
        @for %i in ( $(dlldrv_obj) ) do @%append $^&.lnk file %i
        @%append $^&.lnk lib $(dllname).lib
        $(linker) $(lflags)  @$^&.lnk
#
# done
#

linkfile: .procedure
        @if exist $^&.lnk @rm -f $^&.lnk
        @%write $^&.lnk name $@
        @%append $^&.lnk $(wlink_opt_$(host_os))
        @%append $^&.lnk $(wlink_opt_common)
        @for %i in ( $(cc_objs) ) do @%append $^&.lnk file %i
#       @for %i in ( $(cg_objs) ) do @%append $^&.lnk file $(o_dir)/%i
#       @for %i in ( $($(host_os)_objs) ) do @%append $^&.lnk file $(o_dir)/%i
#       @for %i in ( $(mem_objs) ) do @%append $^&.lnk file $(o_dir)/%i
        @%append $^&.lnk lib $(dwarf_lib)
!ifdef as_lib_$(target_cpu)
        @%append $^&.lnk lib $(asinline_axp_lib)
!endif

!ifeq target_cpu axp

codeaxp.gh :
        echo // Dummy file > $@

!else ifeq target_cpu ppc

codeppc.gh :
        echo // Dummy file > $@

!else  # Intel i86 or 386

!ifdef __LINUX__
#!ifdef bootstrap: codei86.gh is problematic on Linux because it cannot
# execute 16bit executables directly.
code$(target_cpu).gh : code$(target_cpu).s ../a/mkcode.c
        cc -D__$(target_cpu)__ $(INCLUDE) ../a/mkcode.c code$(target_cpu).s -o mkcode
        ./mkcode $^@
	rm -f mkcode
!else
#code$(target_cpu).gh : ./mkcod$(target_cpu).exe
#        $[@ $^@
code$(target_cpu).gh : ./mkcod$(target_cpu)x.bin ./mkcodex.exe
        $]@ $[@ $^@
!endif

code$(target_cpu).s: ../a/code$(target_cpu).asm ../asm2s.sed
        sed -f ../asm2s.sed $[@ > $@

./mkcod$(target_cpu).exe: ../a/code$(target_cpu).asm ../a/mkcode.c
        $(as) $(aflags) $(extra_a_flags_$[&) $[@
!ifeq target_cpu i86
        wcc -zq -ox $]@ @ipaths -fo=.obj
!ifdef __OS2__
        $(linker) sys os2 f { mkcode.obj code$(target_cpu).obj } n $@
!else
        $(linker) sys dos f { mkcode.obj code$(target_cpu).obj } n $@
!endif
!else
        wcc386 -zq $(popt) -ox $]@ @ipaths -fo=.obj
        $(bld_link) f { mkcode.obj code$(target_cpu).obj } n $@
!endif
!endif

./mkcod$(target_cpu)x.bin: ../a/code$(target_cpu)x.asm
        $(as) $(aflags) $(extra_a_flags_$[&) $[@
        $(linker) format dos com option nodefault file code$(target_cpu)x.obj name $^@

./mkcodex.exe: ../a/mkcodex.c
        $(bld_cl) $[@ -fo=$^@

usage.gh: ../usage.sp
        wsplice -k T$(target_cpu) -k H$(host_cpu) -k OS_$(host_os)  "-f\"%s\0\"" ../usage.sp usage.gh

wcc.u: ../usage.sp msgencod.exe intlbin.exe
        wsplice -k T$(target_cpu) -k H$(host_cpu) -k OS_$(host_os) -u -t8 ../usage.sp wcc.u

./usageenc.exe: $(fe_misc_dir)/c/usageenc.c ../jusage.sp
        $(bld_cl) $[@ $(wcl_util_opts)

usage01.int : ./usageenc.exe ../jusage.sp
        wsplice -k T$(target_cpu) -k H$(host_cpu) -k OS_$(host_os) ../jusage.sp usageenc.int
        $[@ usageenc.int usage01.int

./msgencod.exe: $(fe_misc_dir)/c/msgencod.c
        $(bld_cl) $[@ $(wcl_util_opts)

msgtxt.gh msgdefs.gh msgattr.gh errors01.int : ./msgencod.exe ../gml/cerrs.gml
        $[@ -i -ip -q -g ../gml/cerrs.gml msgtxt.gh msgdefs.gh msgattr.gh

./intlbin.exe: $(fe_misc_dir)/c/intlbin.c
        $(bld_cl) $[@ $(wcl_util_opts)

$(intname)01.int : ./intlbin.exe errors01.int usage01.int
        $[@ $(intname)

./genverrc.exe: $(fe_misc_dir)/c/genverrc.c
        $(bld_cl) $[@ $(wcl_util_opts) -D_VERSION=$(bld_ver)

cc.rc : ./genverrc.exe ../rc/r_$(host_os)$(host_cpu).rc
        $[@ ../rc/r_$(host_os)$(host_cpu).rc cc.rc $$ $(dllname).dll $(patch_level)

./mkopcode.exe: $(wasm_dir)/mkopcode.c
        $(bld_cl) $[@ $(wcl_util_opts)

inlnops.gh: ./mkopcode.exe $(wasm_dir)/inlnops.tok
        $[@ $(wasm_dir)/inlnops.tok $^@

key_objs = ../h/c.key ../h/pc.key ../h/seh.key ../h/dummy.key

./findhash.exe : ../../fe_misc/c/findhash.c
        $(bld_cl) $[@ $(wcl_util_opts)

weights.gh keywords.gh : ./findhash.exe $(key_objs)
        $[@ -q $(key_objs)

eraseall.obj : ../compile.gbl
        rm -f *.?bj
        wtouch eraseall.obj

bin_dir_nt      = binnt
bin_dir_os2     = binp
bin_dir_dos     = binw

install: $(dxname) .SYMBOLIC .EXPLICIT
        cp $(dxname) $(%watcom)/$(bin_dir_$(host_os))/wcc$(target_cpu).exe
wccexed: $(dxname) .SYMBOLIC .EXPLICIT
