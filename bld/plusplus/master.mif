proj_name = plusplus

.erase
.continue
.extensions:
.extensions: .qnx .exe .exp .pp .obj .rbj .lbj .asm .c .mif

.mif: $(mif_path)

!ifndef plusplus_trmem
!  ifeq release 0
!      define plusplus_trmem 1
!  endif
!endif

!include cproj.mif

!include $(cg_dir)/mif/fe.mif
!include $(cg_dir)/mif/hostos.mif

!include $(dwarf_dir)/dw/client.mif

!include ../verify.mif
!include ../ppobjs.mif

inc_dirs =.;
!ifdef plusplus_include
inc_dirs += $+$(plusplus_include)$-;
!endif
!ifeq plusplus_trmem 1
inc_dirs += $(trmem_dir);
!endif
inc_dirs += ../h;
inc_dirs += $(cg_inc_dirs);
inc_dirs += $(wasm_dir)/h;
inc_dirs += $(as_dir)/h;
inc_dirs += $(dwarf_dir)/dw/h;
inc_dirs += $(cc_dir)/h;
inc_dirs += $(watcom_dir)/h;
!ifdef comp_cfg_dir
inc_dirs += $(comp_cfg_dir)/h;
!endif
inc_dirs += $(fe_misc_dir)/h;
inc_dirs += $(brinfo_dir)/h

!ifndef patch_level
patch_level=0
!endif

.before
    @set include=$(inc_path)                    # includes 'inc_dirs'

exe_bld_name = wcpp$(target_cpu)
exe_ref_name = rpp$(target_cpu)12
dll_bld_name = wppd$(target_cpu)
!ifndef exe_dbg_name
exe_dbg_name = $(exe_bld_name)d
!endif
!ifndef dll_dbg_name
dll_dbg_name = $(dll_bld_name)d
!endif

comp_objs = $($(host_os)$(target_cpu)_objs)
comp_objs_exe = $(comp_objs) $(exe_objs)
comp_objs_dll = $(comp_objs) $(dll_objs)

cflags =

!ifeq host_cpu axp
!ifeq release 0
cflags += -si
!endif
!else
cflags += -5r-fpc
!endif

!ifdef plusplus_rtdll
cflags += -br
!endif

# personal modifications can be made by including a local .mif file
!ifdef %plusplus_local_mif
!  include $(%plusplus_local_mif)
!else ifdef plusplus_local_mif
!  include $(plusplus_local_mif)
!endif

cflags += -oalrs-s-zq-w4-we -bt=$(host_os)

!ifndef dbg_cflags
!  ifeq release 1
!    define dbg_cflags -d1
!  else
!    define dbg_cflags -d2
!  endif
!endif

!ifeq release 1
cflags += -dNDEBUG -ot
!endif

!ifdef %plusplus_cflags
cflags += $(%plusplus_cflags)
!endif

!ifdef plusplus_cflags
cflags += $(plusplus_cflags)
!endif

!ifeq host_os osi
cflags += -d__OS2__
!endif

# specify any unique options for modules
!ifeq host_cpu axp
# alpha
!ifeq plusplus_trmem 1
extra_opts_memmgr = -dTRACKER
!endif
!else
# all intel
extra_opts_cscan = -4r
extra_opts_srcfile = -4r
!ifeq plusplus_trmem 1
extra_opts_memmgr = -of+ -dTRACKER
!endif
!ifeq release 1
extra_opts_pcheader = -oi
!endif
!endif
# all platforms

!ifdef __LINUX__
fesupp_hdr   = \"fesupp.h\"
carvecpp_hdr = \"carvecpp.h\"
!else
fesupp_hdr   = "fesupp.h"
carvecpp_hdr = "carvecpp.h"
!endif

extra_opts_carve    = -dheader=$(fesupp_hdr) -dheader2=$(carvecpp_hdr)
extra_opts_cmdlnany = -os
extra_opts_idedrv = -dSTATIC_LINKAGE
extra_opts_initfini = -dheader=$(fesupp_hdr) -dSPLIT_REQD
extra_opts_intlload = -d__header=$(fesupp_hdr)
extra_opts_pstk     = -dheader=$(fesupp_hdr)
extra_opts_pstk     = -dheader=$(fesupp_hdr)
extra_opts_ringfns  = -dheader=$(fesupp_hdr)
extra_opts_vbuf     = -dheader=$(fesupp_hdr)
extra_opts_vstk     = -dheader=$(fesupp_hdr)
!ifeq release 1
extra_opts_wppdlldr = -dDLL_NAME=$(dll_bld_name)
!else
extra_opts_wppdlldr = -dDLL_NAME=$(dll_dbg_name)
extra_opts_dbgzap   = -dheader=$(fesupp_hdr)
!endif
!ifdef plusplus_dll_ptree
extra_opts_dbgptree = -dDLL_PTREE
!endif
!ifeq host_os dos
cflags += -dIDE_PGM
!endif
!ifeq host_os osi
cflags += -dIDE_PGM
!endif
!ifeq host_os qnx
cflags += -dIDE_PGM
!endif
!ifeq host_os linux
cflags += -dIDE_PGM
!endif

# WLINK options for the various hosts
extra_l_flags_osi = OPTION stack=64k
extra_l_flags_dos = OPTION dosseg, stack=64k, offset=64k #RUNTIME unpriv
extra_l_flags_os2 = OPTION dosseg, stack=128k, offset=64k
extra_l_flags_qnx = OPTION dosseg, stack=64k, offset=72k, priv=3, resource=usage.u
extra_l_flags_nt  = OPTION dosseg, stack=0x10000k, offset=64k COMMIT stack=32k

# WLINK .DLL options for the various hosts
wlink_dll_os2_386 = OPTION manyautodata

#######################################
# workaround for OW 1.0 WLINK problem 
#######################################
linker+= op caseex
#######################################
extra_l_flags = OPTION map
wlink_opt_common_exe = OPTION symfile
wlink_opt_common_drv = OPTION symfile
!ifeq release 0
# the only guaranteed way to find the .sym for a .DLL is for it to be attached
# to the .DLL binary
wlink_opt_common_dll =
!else
wlink_opt_common_dll = OPTION symfile
!endif
!ifeq host_os nt
wlink_opt_common_dll += OPTION offset=0x69000000
!endif

# WLINK debug info format
!ifndef wlink_dbgfmt
wlink_dbgfmt = DEBUG all
!endif

# final executable extensions for the various hosts
final_exe_dos = exe
final_exe_os2 = exe
final_exe_osi = exe
final_exe_qnx = qnx
final_exe_nt  = exe
final_exe_linux = elf
exe = $(final_exe_$(host_os))

# optencod options and targets for various hosts
optencod_opt_qnx = -u usage.u
optencod_targ_qnx = qnx
optencod_targ_linux = linux
!ifeq release 0
optencod_targ_dbg = dbg
!endif

pre_obj_deps = global.chk errmsgs.gh ic_mask.gh
# international data files
pre_obj_deps += wpp$(target_cpu)01.int
pre_obj_deps += $(pre_obj_deps_wasm)

external_dependencies = $(cg_deps) $(dwarf_dw_dep)

# objects for dll
# obj -- normal object
# lbj -- in DLL
# rbj -- in driver for DLL

.c: ../c;$(wasm_dir)/c;$(watcom_dir)/c;$(fe_misc_dir)/c;$(brinfo_dir)/c

.c.lbj:
        $(cc) $(cflags) $(dbg_cflags) -fo=.lbj -bd-dwpp_dll $[@ $(extra_opts_$[&)

.c.rbj:
        $(cc) $(cflags) $(dbg_cflags) -fo=.rbj -dwpp_drv $[@ $(extra_opts_$[&)

.c.obj:
        $(cc) $(cflags) $(dbg_cflags) -fo=.obj $[@ $(extra_opts_$[&)

.c.pp:
        $(cc) $(cflags) $(dbg_cflags) $[@ $(extra_opts_$[&) -fo=*.pp -p

!ifeq release 1

first : .symbolic build
    @%null

!else

first : .symbolic $(exe_dbg_name).$(exe)
    @%null

!endif

#
# Common dependencies
#
depends_exe = $(pre_obj_deps) $(comp_objs_exe) $(external_dependencies)
depends_dll = $(pre_obj_deps) $(comp_objs_dll) $(external_dependencies)
depends_drv = $(pre_obj_deps) $(dlldrv_objs)


!ifeq host_os dos
#
# DOS executables
#

$(exe_ref_name).exe : $(depends_exe) pexebld.lnk
    $(linker) $(lflags) NAME $^* @pexebld

$(exe_dbg_name).exe : $(depends_exe) pexedbg.lnk
    $(linker) $(lflags) NAME $^* @pexedbg

$(exe_bld_name).exe : $(depends_exe) pexebld.lnk
    $(linker) $(lflags) NAME $^* @pexebld
#    $(pharlap)bind386 $(pharlap)run386b $^*
#    $(pharlap)cfig386 $^* -win30grow -win30limit +524228 -MAXVCPI 0
#!ifeq release 1
#    del $^*.exp
#!endif

build : .symbolic $(exe_bld_name).exe
    @%null


!else ifeq host_os os2
#
# OS/2 2.0 executables
#

$(exe_ref_name).exe : $(depends_exe) pexebld.lnk
    $(linker) $(lflags) NAME $^* @pexebld

plusplus_dll = 1


!else ifeq host_os osi
#
# OS independent executables
#

$(exe_dbg_name).exe : $(depends_exe) pexedbg.lnk $(tools_root)/os2ldr.exe
    $(linker) $(lflags) NAME $^* @pexedbg

$(exe_bld_name).exe : $(depends_exe) pexebld.lnk $(tools_root)/os2ldr.exe
    $(linker) $(lflags) NAME $^* @pexebld
    w32bind $^&.rex $^&.exe $(tools_root)/os2ldr.exe
    del $^&.rex

build : .symbolic $(exe_bld_name).exe
    @%null

!else ifeq host_os nt
#
# Windows/NT executables
#

$(exe_ref_name).exe : $(depends_exe) pexebld.lnk
    $(linker) $(lflags) NAME $^* @pexebld

!ifeq host_cpu 386

plusplus_dll = 1

!else

$(exe_dbg_name).exe : $(depends_exe) pexedbg.lnk
    $(linker) $(lflags) NAME $^* @pexedbg

$(exe_bld_name).exe : $(depends_exe) pexebld.lnk
    $(linker) $(lflags) NAME $^* @pexebld

build : .symbolic $(exe_bld_name).exe
    @%null

!endif


!else ifeq host_os qnx
#
# QNX executables
#

pre_obj_deps += usage.u

$(exe_dbg_name).qnx : $(depends_exe) pexedbg.lnk
    $(linker) $(lflags) NAME $^* @pexedbg

$(exe_bld_name).qnx : $(depends_exe) pexebld.lnk
    $(linker) $(lflags) NAME $^* @pexebld
!ifeq release 1
    serialize $(exe_bld_name).qnx wpp
!endif

build : .symbolic $(exe_bld_name).qnx
    @%null

!else ifeq host_os linux
#
# Linux executables
#

$(exe_ref_name).elf : $(depends_exe) pexebld.lnk
    $(linker) $(lflags) NAME $^*.elf @pexebld

$(exe_dbg_name).elf : $(depends_exe) pexedbg.lnk
    $(linker) $(lflags) NAME $^*.elf @pexedbg

$(exe_bld_name).elf : $(depends_exe) pexebld.lnk
    $(linker) $(lflags) NAME $^*.elf @pexebld

build : .symbolic $(exe_bld_name).elf
    @%null

!else
!error no rules for host_os setting
!endif


!ifdef plusplus_dll
#
# Common for all systems with DLLs
#
lflags_dll = $(mode_lflags) $(lflags_$(host_os)_$(host_cpu)) dll initinstance terminstance $(extra_l_flags_$(host_os)) $(extra_l_flags)

# systems where version resources must be added to .DLL
build_rc_nt_386 = nt

!ifdef build_rc_$(host_os)_$(host_cpu)
rc_objs = plusplus.rc
!endif

build : .symbolic $(exe_bld_name).exe #$(dll_bld_name).dll
    @%null

$(exe_bld_name).exe : $(depends_drv) pdrvbld.lnk $(dll_bld_name).lib
    $(linker) $(lflags) NAME $^* @pdrvbld

$(dll_bld_name).lib : $(dll_bld_name).dll
    $(librarian) -b-q-n $^@ +$[@

$(dll_bld_name).dll : $(rc_objs) $(depends_dll) pdllbld.lnk
    $(linker) $(lflags_dll) NAME $^* @pdllbld
!ifdef build_rc_$(host_os)_$(host_cpu)
    $(rc) $(rc_flags) plusplus.rc $^@
!endif

$(exe_dbg_name).exe : $(depends_drv) pdrvdbg.lnk $(dll_dbg_name).lib
    $(linker) $(lflags) NAME $^* @pdrvdbg

$(dll_dbg_name).lib : $(dll_dbg_name).dll
    $(librarian) -b-q-n $^@ +$[@

$(dll_dbg_name).dll : $(depends_dll) pdlldbg.lnk
    $(linker) $(lflags_dll) NAME $^* @pdlldbg

./genverrc.exe: $(fe_misc_dir)/c/genverrc.c
        $(bld_cl) $(wcl_util_opts) -D_VERSION=$(bld_ver) $[@

plusplus.rc : ./genverrc.exe ../rc/r_$(host_os)$(host_cpu).rc
        $[@ $]@ $^@ $$ $(dll_bld_name).dll $(patch_level)

!endif


!include ../deps.mif

# conventions:
#
# p<xxx>[<yyy>].lnk
#
# xxx - exe = standalone compiler executable
#       drv = stub executable DLL driver
#       dll = compiler DLL
#
# yyy - bld = production version
#       dbg = debugging version
#

#
# compiler standalone executable
#
pexe.lnk : $(__MAKEFILES__)
    %create $^@
    @%append $^@ $(wlink_dbgfmt)
    @%append $^@ $(wlink_opt_common_exe)
    @for %i in ($(comp_objs_exe)) do @%append $^@ file %i
    @%append $^@ library $(dwarf_dw_lib)
!ifdef as_lib
    @%append $^@ library $(as_lib)
!endif

#
# -- production version
#
pexebld.lnk : pexe.lnk
    %create $^@
    @%append $^@ @pexe.lnk
    @%append $^@ $(cg_libs)

#
# -- debugging version
#
pexedbg.lnk : pexe.lnk
    %create $^@
    @%append $^@ @pexe.lnk
    @%append $^@ $(cg_debug_libs)

#
# compiler .DLL driver
#
pdrv.lnk : $(__MAKEFILES__)
    %create $^@
    @%append $^@ $(wlink_dbgfmt)
    @%append $^@ $(wlink_opt_common_drv)
    @for %i in ($(dlldrv_objs)) do @%append $^@ file %i

#
# -- production version
#
pdrvbld.lnk : pdrv.lnk
    %create $^@
    @%append $^@ @pdrv.lnk
    @%append $^@ lib $(dll_bld_name).lib

#
# -- debugging version
#
pdrvdbg.lnk : pdrv.lnk
    %create $^@
    @%append $^@ @pdrv.lnk
    @%append $^@ lib $(dll_dbg_name).lib

#
# .DLL version of compiler
#
pdll.lnk : $(__MAKEFILES__)
    %create $^@
    @%append $^@ $(wlink_dbgfmt)
    @%append $^@ $(wlink_dll_$(host_os)_$(host_cpu))
    @%append $^@ $(wlink_opt_common_dll)
    @for %i in ($(comp_objs_dll)) do @%append $^@ file %i
    @%append $^@ library $(dwarf_dw_lib)
!ifdef as_lib
    @%append $^@ library $(as_lib)
!endif
    @%append $^@ reference __DLLstart_

#
# -- production version
#
pdllbld.lnk : pdll.lnk
    %create $^@
    @%append $^@ @pdll.lnk
    @%append $^@ $(cg_libs)

#
# -- debugging version
#
pdlldbg.lnk : pdll.lnk
    %create $^@
    @%append $^@ @pdll.lnk
    @%append $^@ $(cg_debug_libs)

#
# miscellaneous build rules
#
./intlbin.exe: $(fe_misc_dir)/c/intlbin.c
    $(bld_cl) $[@ $(wcl_util_opts)

wpp$(target_cpu)01.int : ./intlbin.exe errors01.int usage01.int
    $[@ wpp$(target_cpu)

#!ifeq release 1
#msgencod_opts = -w
#!endif

./msgencod.exe: $(fe_misc_dir)/c/msgencod.c
    $(bld_cl) $[@ $(wcl_util_opts)

errmsgs.c errmsgs.gh errlevel.gh errors01.int : ./msgencod.exe ../gml/messages.gml
    $[@ $(msgencod_opts) -i -q ../gml/messages.gml errmsgs.c errmsgs.gh errlevel.gh

./findhash.exe: $(fe_misc_dir)/c/findhash.c
    $(bld_cl) $[@ $(wcl_util_opts)

keywords.gh weights.gh : ./findhash.exe ../hash/plusplus.key ../hash/pc.key
    $[@ -q ../hash/plusplus.key ../hash/pc.key

./umktable.exe: ../c/umktable.c xlat.gh
    $(bld_cl) $[@ $(wcl_util_opts)

yylex.gh : ./umktable.exe
    $[@ $^@

./mktrans.exe: ../c/mktrans.c
    $(bld_cl) $[@ $(wcl_util_opts)

xlat.gh : ./mktrans.exe ../h/ctokens.h keywords.gh ytab.gh
    $[@ $]@ $^@

ytab.c ytab.gh : ../y/plusplus.y ../c/yydriver.c
!ifneq release 0
    $(yacc) -b -d -f -t -u $[@ $]@ >y.out
!else
# The -p and -s switches are v. useful when debugging parser but gen large file!
    $(yacc) -b -d -f -t -u -p -s $[@ $]@ >y.out
!endif
# For some reason yacc delivers slightly different results on Linux?
!ifdef __LINUX__
!else
    # comment out the next line during testing of grammar changes
!ifneq release 0   # debug yacc output may not match stored output
    diff y.out ../y/check.out
!endif
!endif
    rm -f ytab.gh
    cp ytab.h ytab.gh
    rm -f ytab.h

./optencod.exe: $(fe_misc_dir)/c/optencod.c
    $(bld_cl) $[@ $(wcl_util_opts) -i"$(fe_misc_dir)/h"

cmdlnprs.c cmdlnprs.gh cmdlnusg.gh usage.u usage01.int : ./optencod.exe ../gml/options.gml
    $[@ -i -q $(optencod_opt_$(host_os)) $]@ cmdlnprs.gh cmdlnprs.c cmdlnusg.gh $(target_cpu) $(optencod_targ_dbg) $(optencod_targ_$(host_os))

./icmask.exe: ../c/icmask.c
    $(bld_cl) $< $(wcl_util_opts)

ic_mask.gh : ./icmask.exe ../h/ic.h ../c/dwarf.c ../c/cgbkcgrf.c ../c/cgio.c ../c/brmwrite.c
    $[@ ../h/ic.h ../c/dwarf.c ../c/cgbkcgrf.c ../c/cgio.c ../c/brmwrite.c

./mkopcode.exe: $(wasm_dir)/mkopcode.c
        $(bld_cl) $[@ $(wcl_util_opts)

inlnops.gh: ./mkopcode.exe $(wasm_dir)/inlnops.tok
        $[@ $(wasm_dir)/inlnops.tok $^@

#
# list of target architectures that have built-in code bursts
has_prag_i86 = yes
has_prag_386 = yes

!ifdef has_prag_$(target_cpu)

code$(target_cpu).gh : xcode$(target_cpu).tmp ./mkcode.exe
        $]@ $[@ $^@

xcode$(target_cpu).tmp: $(cc_dir)/a/code$(target_cpu).asm
        $(as) $(aflags) $(extra_a_flags_$[&) $[@
        $(linker) format dos com op nodefault file code$(target_cpu).obj name $^@ disable 1023,1080

./mkcode.exe: $(cc_dir)/a/mkcode.c
        $(bld_cl) $[@ $(wcl_util_opts)

!endif

#
# create reference compiler
#
reference : .symbolic $(exe_ref_name).$(exe)
!ifdef __LINUX__
    cp $(exe_ref_name).$(exe) ../bin/$(exe_ref_name)
    rm -f $(exe_ref_name).*
!else
    copy /b $(exe_ref_name).$(exe)+$(exe_ref_name).sym ..\bin\$(exe_ref_name).$(exe)
    del $(exe_ref_name).*
!endif

#
# list of projects required to build the plusplus project
#
project : .symbolic
    pexist build
    pexist watcom
    pexist fe_misc
    pexist brinfo
    pexist cc
    pexist dwarf
    pexist owl          # target_cpu == axp
    pexist cg
    pexist as           # target_cpu == axp
    pexist wasm         # target_cpu == i86 or 386
    pexist trmem        # plusplus_trmem def'd

#
# add audit trail to compile.gbl to force global recompile on refresh
#
global.chk : ../compile.gbl
    %make clean
!ifdef __LINUX__
    touch -r $[@ $^@
!else
    wtouch -f $[@ $^@
!endif

clean global : .symbolic
    @rm -f *.?bj *.lib *.pch *.lst *.gh *.rc *.int *.res *.err *.tmp
    @rm -f *.cod *.asm *.dmp *.lnk *.bak *.dll *.pdb errmsgs.c y.out ytab.*
    @rm -f cmdlnprs.* usage.u global.chk
    @rm -f usage.u @del usage.u $(exe_dbg_name).* $(exe_bld_name).*
    @rm -f $(exe_ref_name).* ../bin/$(exe_ref_name).* $(dll_bld_name).*
    @rm -f $(dll_dbg_name).* mkopcode.* optencod.* msgencod.*
    @rm -f icmask.* intlbin.* mkcode.* findhash.* mktrans.* umktable.*

