(13)"/*  *  Simple"
(13)"program    to"
(13)"read    STDIN"
(13)"and   justify"
(13)"the  text  to"
(13)"the         *"
(13)"specified    "
(13)"number     of"
(13)"columns   and"
(13)"output     to"
(13)"STDOUT. * The"
(13)"padding    is"
(13)"alternated   "
(13)"from line  to"
(13)"line so as to"
(13)"look  even. *"
(13)"Blank   lines"
(13)"in  the input"
(13)"stream    are"
(13)"preserved.  *"
(13)"This      was"
(13)"designed   to"
(13)"be used as  a"
(10)"filter. */"

(13)"#include     "
(13)"<iostream.h> "
(13)"#include     "
(10)"<stdlib.h>"

(13)"#include     "
(13)""splash.h"   "
(13)"#include     "
(10)""tracer.h""

(13)"//       Some"
(13)"useful       "
(13)"synonyms     "
(13)"typedef      "
(13)"SPString Str;"
(13)"typedef      "
(13)"SPStringList "
(8)"StrList;"

(11)"int tog= 0;"

(13)"static    int"
(18)"nextnonspace(const"
(13)"Str&  s,  int"
(13)"n)  { while(n"
(13)"<  s.length()"
(13)"&&  s[n] == '"
(13)"')       n++;"
(11)"return n; }"

(13)"static    int"
(18)"prevnonspace(const"
(13)"Str&  s,  int"
(13)"n)  { while(n"
(13)">= 0 &&  s[n]"
(13)"==  ' ') n--;"
(11)"return n; }"

(13)"void         "
(13)"justify(Str& "
(13)"ln,       int"
(13)"width)      {"
(19)"TRACER("justify(Str"
(13)"ln,       int"
(13)"width)")     "
(13)"LTRACE(2, ln)"
(13)"int   p,   o="
(18)"tog?0:ln.length();"
(17)"while(ln.length()"
(13)"<     width){"
(13)"if(tog){   //"
(13)"left to right"
(13)"pad        p="
(13)"ln.index(" ","
(13)"o); // find a"
(13)"space if(p  >"
(13)"0){          "
(13)"ln.substr(p, "
(13)"0)=  "  "; //"
(13)"insert      a"
(13)"space      o="
(16)"nextnonspace(ln,"
(13)"p); //  start"
(13)"from     next"
(13)"non-space    "
(13)"}else   if(o)"
(13)"o=   0;    //"
(13)"reset else ln"
(13)"+=  "  ";  //"
(13)"put at end of"
(13)"line   }else{"
(13)"//  right  to"
(13)"left  pad  p="
(13)"ln.rindex("  "
(13)"",   o);   //"
(13)"find  a space"
(13)"if(p  >   0){"
(13)"ln.substr(p, "
(13)"0)= "  ";  //"
(13)"insert      a"
(13)"space      o="
(16)"prevnonspace(ln,"
(13)"p);  // start"
(13)"from previous"
(13)"non-space    "
(13)"}else if(o !="
(13)"ln.length()) "
(13)"o=           "
(13)"ln.length(); "
(13)"// reset else"
(13)"ln += " "; //"
(13)"put at end of"
(13)"line } }  tog"
(7)"^= 1; }"

(13)"int  main(int"
(13)"argc,    char"
(13)"**argv)     {"
(17)"FTRACER("main()","
(13)"0, cout)  Str"
(13)"inl,   curln,"
(13)"curword;     "
(13)"StrList      "
(13)"words;    int"
(10)"width= 79;"

(13)"if(argc < 2){"
(13)"cerr       <<"
(13)""Usage:      "
(13)"justify      "
(13)"width"     <<"
(13)"endl;        "
(10)"exit(1); }"

(13)"width=       "
(14)"atoi(argv[1]);"
(13)"while(cin  >>"
(13)"inl){        "
(13)"LTRACE(2,    "
(13)"inl)         "
(15)"if(inl.length()"
(13)"==   0){   //"
(13)"honour       "
(13)"existing     "
(13)"blank   lines"
(18)"if(curln.length())"
(13)"cout << curln"
(13)"<<  endl;  //"
(13)"flush        "
(13)"previous line"
(13)"cout << endl;"
(13)"//     output"
(13)"blank    line"
(13)"curln=    "";"
(13)"continue;   }"
(23)"words.push(inl.split("'"
(13)"'"));  // put"
(13)"at   end   of"
(13)"word     FIFO"
(13)"LTRACE(2,    "
(13)"words)       "
(13)"while(words){"
(17)"if(curln.length()"
(13)"== 0)  curln="
(14)"words.shift();"
(13)"//  get first"
(13)"word         "
(20)"while(curln.length()"
(13)"<     width){"
(13)"if(!words)   "
(13)"break;     //"
(13)"need       to"
(13)"refill   FIFO"
(13)"curword=     "
(14)"words.shift();"
(13)"//  next word"
(17)"if(curln.length()"
(13)"+            "
(16)"curword.length()"
(13)"+ 1 > width){"
(23)"words.unshift(curword);"
(13)"//   put   it"
(13)"back         "
(14)"justify(curln,"
(13)"width);    //"
(13)"pads     with"
(13)"spaces     to"
(13)"width   }else"
(13)"curln += (" ""
(13)"+   curword);"
(13)"//  add  word"
(13)"to   line   }"
(17)"if(curln.length()"
(13)">= width){ //"
(13)"done     with"
(13)"this     line"
(13)"cout << curln"
(13)"<<      endl;"
(13)"curln=  ""; }"
(13)"}           }"
(18)"if(curln.length())"
(13)"cout << curln"
(13)"<<      endl;"
(13)"return( 0  );"
(1)"}"
