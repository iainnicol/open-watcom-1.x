1a2,3
> #include <string.h>
> #include <stdio.h>
3c5,6
< #include "common.h"
---
> #include "common.hpp"
> #include "cverror.hpp"
5,8c8,15
< #include "retrieve.h"
< #include "subsection.h"
< #include "packtype.h"
< #include "cverror.h"
---
> #include "typemap.hpp"
> #include "cvpack.hpp"
> #include "retrieve.hpp"
> #include "makeexe.hpp"
> #include "subsect.hpp"
> #include "packtype.hpp"
> #include "cssymbol.hpp"
> #include "symdis.hpp"
9a17
> 
11c19
<                                   "Information Compactor Version 0.00\n"\
---
>                                   "Information Compactor Version 1.00\n"\
15,17c23
< void outOfMemory() {
<     throw OutOfMemory();
< }
---
> static const char* CVpackUsage = "usage : cvpack [/nologo] <exefile>\n";
19c25,26
< int main(int argc, char* argv[]) {
---
> static const MAX_FILE_NAME = 256;
> static char  fName[MAX_FILE_NAME];
21c28,29
<     set_new_handler(outOfMemory);
---
> // map table for type indices.
> TypeIndexMap    TypeMap;
23,54c31,34
<     cout << CVpackHeader << endl;
< 
<     try {
<         ifstream  fd(argv[1], ios::in | ios::binary);
<         if ( !fd ) {
<             throw FileError(argv[1]);
<         }
< 
<         Retriever aRetriever(fd);
<         if ( !aRetriever.CheckSig() ) {
<             throw CVSigError();
<         }
< 
<         char* buffer = NULL;
<         unsigned_16 module = 1;
<         unsigned_32 length = aRetriever.ReadSubsection(buffer,sstTypes,module);
< 
< 
<         SstGlobalTypes globalType(buffer,length);
<         //TypeIndexMap   TIMap( CV_FIRST_NONPRIM + globalType.Entries() );
<         //SstTypes       localType;
< 
< 
<         //localType.PackTypes(globalType,TIMap);
< /*      for ( length = aRetriever.ReadSubsection(buffer,sstTypes,++module);
<               length != 0;
<               length = aRetriever.ReadSubsection(buffer,sstTypes,++module) ) {
<             localType.Load(buffer,length);
<             delete [] buffer; // release memory.
<             localType.PackType(globalType,TIMap);
<             TIMap.reset();
<         }  */
---
> // Table of numeric leaf size except variable length string, because its
> // length is not constant.
> static const NumLeafSize[] = { 1, 2, 2, 4, 4, 4, 8, 10,
>                                16, 8, 8, 6, 8, 16, 20, 32 };
56,63c36,43
< /*        TypeIndexMap TIMap(0x1005);
<         for ( int i = 0x1000; i < 0x1400; i++ ) {
<             TIMap.Insert(i);
<         }
<         cout << hex << TIMap.Lookup(0x1399) << endl;
<         cout << hex << TIMap.Lookup(0x1000) << endl;
<         cout << TIMap.Lookup(0x2000) << dec << endl;
<         TIMap.reset(); 
---
> //
> // This function returns the length of a numeric leaf starting at buffer.
> //
> uint NumLeafLength( const char* buffer )
> /**************************************/
> {
>     uint length = 0;
>     uint index = * (unsigned_16 *) buffer;
65,68c45,46
< /*        char *      buffer;
<         unsigned_16 len;
<         unsigned_16 index;
<         unsigned_32 version;
---
>     // skip the index of the numeric leaf.
>     buffer += WORD;
70,81c48,49
<         buffer = (char *) aRetriever.ReadSubsection(sstTypes,1);
<         if ( buffer ) {
<             version = * (unsigned_32 *) buffer;
<             buffer += 4;
<             len = * (unsigned_16 *) buffer;
<             cout << version << endl;
<             buffer += 2;
<             cout << len << endl;
<             index = * (unsigned_16 *) buffer;
<             cout << hex << index << endl;
<             delete [] buffer;
<         } */
---
>     // length of the leaf index.
>     length += WORD; 
82a51,58
>     //
>     // If it is a variable length string, its length is specified by the
>     // next 2 bytes.
>     //
>     if ( index == LF_VARSTRING ) {
>         length += * (unsigned_16 *) buffer;
>     } else if ( index >= LF_NUMERIC ) {
>         length += NumLeafSize[index-LF_NUMERIC];
83a60,61
>     return length;
> }
85,87c63,69
<     catch (CVpackError& CVerr) {
<         CVerr.ErrorPrint();
<         exit(1);
---
> inline
> void ConvertFName( char* f )
> /**************************/
> {
>     strcpy(fName,f);
>     if ( strchr(f,'.') == NULL ) {
>         strcat(fName,".exe");
89d70
<     return 0;
91c72,85
<         throw MiscError(strerror(errno));
---
> void outOfMemory() {
> /******************/
>     throw OutOfMemory();
> }
> 
> inline
> void CVpack::DoExeCode()
> /**********************/
> {
>     unsigned_32 length = _aRetriever.TellExeLength();
>     if ( length ) {
>         char* buffer = new char [length];
>         if ( ! _aRetriever.ReadExeCode(buffer) ) {
>             throw MiscError("error while reading executable code.");
93,97c87,91
<     } 
<     catch (CVpackError& CVerr) {
<         CVerr.ErrorPrint();
<         remove(tmpFile);
<         exit(1);
---
>         _eMaker.DumpToExe(buffer,length);
>         _lfaBase = length;
>         delete [] buffer;
>     } else {
>         throw MiscError("no executable code present.");
99d92
<     return 0;
101d93
<  }
103,104c95,99
<         SstGlobalTypes globalType(buffer,length);
<         SstTypes       localType(buffer,length);
---
> inline uint CVpack::DoSstModule()
> /*******************************/
> {
>     char*       buffer;
>     unsigned_32 length;
106,107c101,108
<         TypeMap.Set( localType.Entries(),
<                      CV_FIRST_NONPRIM + globalType.Entries() );
---
>     for ( uint module = 1;
>           _aRetriever.ReadSubsection(buffer,length,sstModule,module);
>           module++ ) {
>         _newDir.Insert(sstModule,module,OFBase(),length);
>         _eMaker.DumpToExe(buffer,length);
>     }
>     return module-1;
> }
109c110,114
<         LFGlobalTypeRecord::SetGlobalSubsection(globalType);
---
> inline void CVpack::DumpSig()
> /***************************/
> {
>     _eMaker.DumpToExe(NB09, LONG_WORD);
> }
111,112c116,128
<         LFLeafStruct::SetGlobal(&globalType);
<         LFLeafStruct::SetLocal(&localType);
---
> inline uint CVpack::DoSrcModule( const uint module )
> /**************************************************/
> {
>     unsigned_32 length;
>     char*       buffer;
>     if ( _aRetriever.ReadSubsection(buffer,length,sstSrcModule,module) ) {
>         _newDir.Insert(sstSrcModule,module,OFBase(),length);
>         _eMaker.DumpToExe(buffer,length);
>         return ( * (unsigned_16 *) (buffer + WORD) );
>     } else {
>         throw MiscError("no sstSrcModule present for detected module");
>     }
> }
114d129
<         localType.PackTypes(globalType); 
116,134c131,142
<         //
<         // Selectively destruct the ones that already exists in the global
<         // depository.
<         //
<         localType.SelectiveDestruct(); 
< 
<         delete [] buffer;  
<         SstGlobalSym      globalSym;
<         SstStaticSym      staticSym;
<         SymbolDistributor symDis(aRetriever,globalSym,staticSym);
<         SstAlignSym       alignSym;
<         symDis.Distribute(1,alignSym); */
< 
<     } 
< 
<     catch (CVpackError& CVerr) {
<         CVerr.ErrorPrint();
<         remove(tmpFile);
<         exit(1);
---
> uint CVpack::DoSegMap()
> /*********************/
> {
>     uint        cSeg = 0;
>     unsigned_32 length;
>     char*       buffer;
>     if ( _aRetriever.ReadSubsection(buffer,length,sstSegMap) ) {
>         cSeg = * (unsigned_16 *) buffer;
>         _newDir.Insert(sstSegMap,MODULE_INDEPENDENT,OFBase(),length);
>         _eMaker.DumpToExe(buffer,length);
>     } else {
>         throw MiscError("no sstSegMap present.");
136c144
<     return 0;
---
>     return cSeg;
138,156d145
<         throw MiscError(strerror(errno));
<         }
<     } 
<     catch (CVpackError& CVerr) {
<         CVerr.ErrorPrint();
<         remove(tmpFile);
<         exit(1);
<     }
<     return 0;
< }
<     length = aRetriever.ReadSubsection(buffer,sstGlobalTypes);
<                 unsigned_32 count = * (unsigned_32 *) (buffer + 4);
<                 buffer += 4 + 4 * count;
<             } 
<         } else {  
<             length = aRetriever.TellLength(sstTypes,module);
<             buffer = new char [length];
<             aRetriever.ReadSubsection(buffer,sstTypes,module);
<         }
158,159c147,163
<         SstGlobalTypes globalType(buffer,length);
<         SstTypes       localType(buffer,length);
---
> void CVpack::DoAlignSym( SstAlignSym*      alignSym,
>                          const uint        module )
> /**************************************************/
> {
>     _newDir.Insert(sstAlignSym,module,OFBase(),alignSym -> Length());
>     alignSym -> Put(_eMaker);
> }
> 
> inline
> void CVpack::DoGlobalSym( SstGlobalSym& globalSym, const uint cSeg )
> /******************************************************************/
> {
>     unsigned_32 oldOffset = OFBase();
>     globalSym.Put(_eMaker,cSeg);
>     unsigned_32 length = OFBase() - oldOffset;
>     _newDir.Insert(sstGlobalSym,MODULE_INDEPENDENT,oldOffset,length);
> }
161,162c165,173
<         TypeMap.Set( localType.Entries(),
<                      CV_FIRST_NONPRIM + globalType.Entries() );
---
> inline
> void CVpack::DoStaticSym( SstStaticSym& staticSym, const uint cSeg )
> /******************************************************************/
> {
>     unsigned_32 oldOffset = OFBase();
>     staticSym.Put(_eMaker,cSeg);
>     unsigned_32 length = OFBase() - oldOffset;
>     _newDir.Insert(sstStaticSym,MODULE_INDEPENDENT,oldOffset,length);
> }
164c175,183
<         LFGlobalTypeRecord::SetGlobalSubsection(globalType);
---
> inline
> void CVpack::DoDirectory()
> /************************/
> {
>     streampos dirOffset = OFBase();
>     _newDir.Put(_eMaker);
>     DumpSig();
>     // compute lfoBase and dump it out.
>     _eMaker.DumpToExe((unsigned_32)(_eMaker.TellPos()+LONG_WORD-_lfaBase));
166,190c185,186
<         LFLeafStruct::SetGlobal(&globalType);
<         LFLeafStruct::SetLocal(&localType);
< 
<         localType.PackTypes(globalType); 
< 
<         //
<         // Selectively destruct the ones that already exists in the global
<         // depository.
<         //
<         localType.SelectiveDestruct(); 
< 
<         delete [] buffer;  
<         SstGlobalSym      globalSym;
<         SstStaticSym      staticSym;
<         SymbolDistributor symDis(aRetriever,globalSym,staticSym);
<         SstAlignSym       alignSym;
<         symDis.Distribute(1,alignSym); */
< 
<     } 
< 
<     catch (CVpackError& CVerr) {
<         CVerr.ErrorPrint();
<         exit(1);
<     }
<     return 0;
---
>     _eMaker.SeekTo(_lfaBase+LONG_WORD);
>     _eMaker.DumpToExe((unsigned_32)dirOffset);
192c188,202
<         throw MiscError(strerror(errno));
---
> 
> inline
> void CVpack::DoPublics( const uint segNum,
>                         const uint moduleNum )
> /********************************************/
> {
>     unsigned_32  length;
>     uint         index;
>     char*        buffer = NULL;
>     char*        ptr = NULL;
>     char*        end = NULL;
>     SstGlobalPub globalPub;
>     for ( uint module = 1; module <= moduleNum; module++ ) {
>         if ( ! _aRetriever.ReadSubsection(buffer,length,sstPublicSym,module)) {
>             continue;
194,198c204,215
<     } 
<     catch (CVpackError& CVerr) {
<         CVerr.ErrorPrint();
<         remove(tmpFile);
<         exit(1);
---
>         ptr = buffer;
>         end = &ptr[length];
>         ptr += LONG_WORD; // skip 0x00000001 header.
>         while ( ptr < end ) {
>             index = * (unsigned_16 *)(ptr + WORD);
>             if ( index == S_PUB16 ) {
>                 globalPub.Insert(CSPub16::Construct(ptr));
>             } else if ( index == S_PUB32 ) {
>                 globalPub.Insert(CSPub32::Construct(ptr));
>             }
>             ptr += * (unsigned_16 *) ptr + WORD;
>         }
200c217,222
<     return 0;
---
>     unsigned_32 oldOffset = OFBase();
>     globalPub.Put(_eMaker,segNum);
>     unsigned_32 secLen = OFBase() - oldOffset;
>     if ( secLen != 0 ) {
>         _newDir.Insert(sstGlobalPub,MODULE_INDEPENDENT,oldOffset,secLen);
>     }
202,203d223
< length];
<             _aRetriever.ReadSubsection(buffer,sstTypes,1);
205,206c225,257
<         SstGlobalTypes globalType(buffer,length);
<         delete [] buffer; 
---
> inline
> void CVpack::DoLibraries()
> /************************/
> {
>     unsigned_32 length;
>     char*       buffer;
>     if ( _aRetriever.ReadSubsection(buffer,length,sstLibraries) ) {
>         _newDir.Insert(sstLibraries,MODULE_INDEPENDENT,OFBase(),length);
>         _eMaker.DumpToExe(buffer,length);
>     }
> }
>     
> inline
> void CVpack::DoGlobalTypes( SstGlobalTypes& globalType )
> /******************************************************/
> {
>     unsigned_32 oldOffset = OFBase();
>     globalType.Put(_eMaker);
>     unsigned_32 length = OFBase() - oldOffset;
>     _newDir.Insert(sstGlobalTypes,MODULE_INDEPENDENT,oldOffset,length);
> }
> 
> void CVpack::CreatePackExe()
> /**************************/
> {
>     uint moduleNum = 0;
>     // number of segment received code from a module.
>     uint moduleSeg = 0;
>     DoExeCode();
>     DumpSig();
>     // reserve for directory offset.
>     _eMaker.Reserve(LONG_WORD); 
>     moduleNum = DoSstModule();
208,212c259,260
< //        TypeMap.Set( localType.Entries(),
< //                     CV_FIRST_NONPRIM + globalType.Entries() );
< // code end.
< 
< //    SstGlobalTypes globalType(buffer, length);
---
>     SstGlobalTypes globalType;
>     SstAlignSym*   alignSym;
214a263
>     bool	   gottype;
216,224c265,277
<     for ( unsigned_16 module = 1; ; module++ ) {
<         SstAlignSym* alignSym = new SstAlignSym;
<         if ( ! symDis.Distribute(module, *alignSym) ) {
<             delete alignSym;
<             break;
<         }
<         DoAlignSym(alignSym, module);
<         DoSrcModule(module);
<         delete alignSym;
---
>     for ( uint module = 1; ; module++ ) {
> 	if( _aRetriever.IsAtSubsection( sstSegMap ) ) break;
> 	gottype = globalType.LoadTypes(_aRetriever,module);
>         moduleSeg = DoSrcModule(module);
> 	if( gottype ) {
> 	    alignSym = new SstAlignSym(moduleSeg);
> 	    if ( ! symDis.Distribute(module, *alignSym) ) {
> 		delete alignSym;
> 		break;
> 	    }
> 	    DoAlignSym(alignSym, module);
> 	    delete alignSym;
> 	}
226c279
<     unsigned_16 cSeg = DoSegMap();
---
>     uint cSeg = DoSegMap();
232a286
>     _eMaker.Close();
235d288
< int main(int argc, char* argv[]) {
237c290,294
<     set_new_handler(outOfMemory);
---
> int main(int argc, char* argv[]) 
> /******************************/
> {
>     char tmpFile[L_tmpnam];
>     bool quiet;
239,242c296,297
<     cout << CVpackHeader << endl;
<     SymbolStruct a;
<     foo tryout(12,&a);
< 
---
>     quiet = FALSE;
>     set_new_handler(outOfMemory);
244,246c299,306
<         ifstream  fd(argv[1], ios::in | ios::binary);
<         if ( !fd ) {
<             throw FileError(argv[1]);
---
>         if( argc != 2 ) {
> 	    if( argc == 3 && stricmp( argv[1], "/nologo" ) == 0 ) {
> 		quiet = TRUE;
> 		argv[1] = argv[2];
> 	    } else {
> 		cerr << CVpackUsage;
> 		return 1;
> 	    }
248,249c308,315
< 
<         char tmpFile[L_tmpnam];
---
> 	if( !quiet ) {
> 	    cout << CVpackHeader << endl;
> 	}
>         ::ConvertFName(argv[1]);
>         ifstream  fd(fName, ios::in | ios::binary);
>         if ( !fd ) {
>             throw FileError(fName);
>         }
253,255c319,321
< /*        Retriever aRetriever(fd);
<         if ( !aRetriever.CheckSig() ) {
<             throw CVSigError();
---
>         fd.close();
>         if ( remove(fName) ) {
>             throw MiscError(strerror(errno));
257,395c323,324
< 
<         char* buffer = NULL;
<         unsigned_16 module = 1;
<         unsigned_32 length = 0;
< 
<         // testing purpose.
<         if ( argc > 2 ) {
<             if ( argv[2][0] == 'g' ) {
<                 // temp code for testing purpose.
<                 length = aRetriever.ReadSubsection(buffer,sstGlobalTypes);
<                 unsigned_32 count = * (unsigned_32 *) (buffer + 4);
<                 buffer += 4 + 4 * count;
<             } 
<         } else {  
<             length = aRetriever.TellLength(sstTypes,module);
<             buffer = new char [length];
<             aRetriever.ReadSubsection(buffer,sstTypes,module);
<         }
< 
<         SstGlobalTypes globalType(buffer,length);
<         SstTypes       localType(buffer,length);
< 
<         TypeMap.Set( localType.Entries(),
<                      CV_FIRST_NONPRIM + globalType.Entries() );
< 
<         LFGlobalTypeRecord::SetGlobalSubsection(globalType);
< 
<         LFLeafStruct::SetGlobal(&globalType);
<         LFLeafStruct::SetLocal(&localType);
< 
<         localType.PackTypes(globalType); 
< 
<         //
<         // Selectively destruct the ones that already exists in the global
<         // depository.
<         //
<         localType.SelectiveDestruct(); 
< 
<         delete [] buffer;  
<         SstGlobalSym      globalSym;
<         SstStaticSym      staticSym;
<         SymbolDistributor symDis(aRetriever,globalSym,staticSym);
<         SstAlignSym       alignSym;
<         symDis.Distribute(1,alignSym); */
< 
<     } 
< 
<     catch (CVpackError& CVerr) {
<         CVerr.ErrorPrint();
<         exit(1);
<     }
<     return 0;
< }
<         throw MiscError(strerror(errno));
<         }
<     } 
<     catch (CVpackError& CVerr) {
<         CVerr.ErrorPrint();
<         remove(tmpFile);
<         exit(1);
<     }
<     return 0;
< }
<  }
< 
<         SstGlobalTypes globalType(buffer,length);
<         SstTypes       localType(buffer,length);
< 
<         TypeMap.Set( localType.Entries(),
<                      CV_FIRST_NONPRIM + globalType.Entries() );
< 
<         LFGlobalTypeRecord::SetGlobalSubsection(globalType);
< 
<         LFLeafStruct::SetGlobal(&globalType);
<         LFLeafStruct::SetLocal(&localType);
< 
<         localType.PackTypes(globalType); 
< 
<         //
<         // Selectively destruct the ones that already exists in the global
<         // depository.
<         //
<         localType.SelectiveDestruct(); 
< 
<         delete [] buffer;  
<         SstGlobalSym      globalSym;
<         SstStaticSym      staticSym;
<         SymbolDistributor symDis(aRetriever,globalSym,staticSym);
<         SstAlignSym       alignSym;
<         symDis.Distribute(1,alignSym); */
< 
<     } 
< 
<     catch (CVpackError& CVerr) {
<         CVerr.ErrorPrint();
<         remove(tmpFile);
<         exit(1);
<     }
<     return 0;
< }
<         throw MiscError(strerror(errno));
<         }
<     } 
<     catch (CVpackError& CVerr) {
<         CVerr.ErrorPrint();
<         remove(tmpFile);
<         exit(1);
<     }
<     return 0;
< }
< ectiveDestruct(); 
< 
<         delete [] buffer;  
<         SstGlobalSym      globalSym;
<         SstStaticSym      staticSym;
<         SymbolDistributor symDis(aRetriever,globalSym,staticSym);
<         SstAlignSym       alignSym;
<         symDis.Distribute(1,alignSym); */
< 
<     } 
< 
<     catch (CVpackError& CVerr) {
<         CVerr.ErrorPrint();
<         remove(tmpFile);
<         exit(1);
<     }
<     return 0;
< }
<         throw MiscError(strerror(errno));
<         }
<     } 
<     catch (CVpackError& CVerr) {
<         CVerr.ErrorPrint();
<         remove(tmpFile);
<         exit(1);
<     }
<     return 0;
< }
<      throw MiscError(strerror(errno));
---
>         if ( rename(tmpFile,fName) ) {
>             throw MiscError(strerror(errno));
